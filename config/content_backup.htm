<h1>Python 安裝</h1>
<h4>Windows 操作系統</h4>
<p>利用瀏覽器連結至 <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a> 後, 從 <a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a> 下載 <a href="https://www.python.org/ftp/python/3.7.2/python-3.7.2rc1-amd64.exe">https://www.python.org/ftp/python/3.7.2/python-3.7.2rc1-amd64.exe</a>, 在 Windows 10 64 位元環境中安裝, 即可從 cmd 命令列中, 以 python 指令使用互動式指令環境.</p>
<p>可攜 Python 系統: <a href="https://drive.google.com/open?id=1qSnGb4NBmfGG0jGVNfQJX_9TNVweIdFW">p37-18.12.7z</a> (下載解開壓縮檔案後, 以 start.bat 啟動後即可使用)</p>
<h4>Ubuntu 操作系統</h4>
<p>比較方便使用的 Ubuntu 操作系統, 可以在 Windows 10 64 位元環境中, 安裝 <a href="https://www.virtualbox.org/wiki/Downloads">Virtualbox</a> 虛擬環境後, 再安裝 Ubuntu LTS 版本.</p>
<h1>電腦硬體</h1>
<p><a href="/downloads/Computer_Overview_and_hardware.pdf">computer overview and hardware.pdf</a></p>
<p>(<a href="https://www.cs.auckland.ac.nz/compsci111ssc/lectures/LectureSlides/">https://www.cs.auckland.ac.nz/compsci111ssc/lectures/LectureSlides/</a>)</p>
<h4>Computer 硬體</h4>
<p><img alt="" height="248" src="/images/computer_hardware.png" width="600"/></p>
<h4>Personal Computer 類別</h4>
<p><img alt="" height="262" src="/images/computer_types.png" width="600"/></p>
<h4>機架式(rack)電腦伺服器</h4>
<p><img alt="" height="334" src="/images/rack_server.png" width="600"/></p>
<h4>UPS (Uninterruptible Power Supply) 不斷電系統</h4>
<p><img alt="" height="450" src="/images/APC_smart_ups.jpg" width="600"/></p>
<h4>Motherboard 主機板</h4>
<p><img alt="" height="395" src="/images/motherboard.png" width="600"/></p>
<h4>PCI (<span>Peripheral Component Interconnect)</span>網路卡</h4>
<p><img alt="" height="320" src="/images/Ethernet_NIC_100Mbit_PCI.jpg" width="600"/></p>
<h4>Power Supply 電源供應器</h4>
<p><img alt="" height="466" src="/images/power_supply.jpg" width="466"/></p>
<h4>個人桌上型電腦內部</h4>
<p><img alt="" height="358" src="/images/inside_desktop.png" width="600"/></p>
<h4>筆記型電腦內部</h4>
<p><img alt="" height="320" src="/images/insite_laptop.png" width="600"/></p>
<h1>Python 語法</h1>
<p>Python 3 官方教材: <a href="https://docs.python.org/3/index.html">https://docs.python.org/3/index.html</a> </p>
<p>Python tutorial: <a href="https://docs.python.org/3/tutorial/index.html">https://docs.python.org/3/tutorial/index.html</a> (英文)</p>
<p>Python 教學: <a href="https://python-doc-tw.github.io/tutorial/index.html">https://python-doc-tw.github.io/tutorial/index.html</a> </p>
<p>網頁上的 Python - Brython: <a href="https://www.brython.info/static_doc/en/intro.html">https://www.brython.info/static_doc/en/intro.html</a>  (解譯式)</p>
<p>網頁上的 Python GUI- Flexx: <a href="https://flexx.readthedocs.io/en/stable/">https://flexx.readthedocs.io/en/stable/</a> (轉譯式)</p>
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- for ggame -->
<script src="/static/jquery-3.3.1.min.js"></script>
<script src="/static/jquery-ui.1.12.1.min.js"></script>
<script src="/static/pixi-3.0.5.min.js"></script>
<script src="/static/buzz-1.2.1.js"></script>
<script src="/static/bs.js"></script>
<!-- Cango 程式庫 -->
<script src="/static/Cango-13v08-min.js"></script>
<script src="/static/CangoAxes-4v01-min.js"></script>
<script src="/static/gearUtils-05.js"></script>
<!-- for Konva 程式庫 -->
<script src="/static/konva.min.js"></script>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["py_src"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<h4>開始練習 print() 用法, 並著手建立函式</h4>
<p><!-- 印出版次與關鍵字程式 --></p>
<p>
<script type="text/python3">
from browser import document as doc
from browser import html
import ace

# 清除畫布
def clear_bd(ev):
    bd = doc["brython_div"]
    bd.clear()

# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )

Ace.editor.setValue("""# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword

def helloWorld():
    print("Hello World!")

helloWorld()

# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
""")
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
doc['clear_bd'].bind('click', clear_bd)
</script>
</p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src', 'kw_filename');" type="submit" value="Save"/></form>
<p><button id="kw_run">Run</button> <button id="kw_show_console">Output</button> <button id="kw_clear_console">清除輸出區</button><button id="clear_bd">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console"></textarea></div>
<div id="brython_div"></div>
<div class="col-md-0" height="1" id="graphics-column" width="1"></div>
<p><!-- ****************************** keyword start -->
<script type="text/python3">
from browser import document as doc
# 導入位於 static 目錄下的 beditor.py 
import beditor
# 利用 beditor.py 中的 editor 類別建立案例, 對應到 kw1
kw1 = beditor.editor("""# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword

# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "keyword" 的按鈕點按時, 執行 kw1 物件中的 prog 方法
doc["keyword"].bind('click', kw1.prog)
</script>
</p>
<p><!-- ****************************** keyword end --></p>
<p><!-- ***************************** slide ex1 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex1 = beditor.editor("""# 導入 Ex1 原始碼
a = 0
def my_print(n, input_str):
    print("以下將重覆列印 '", input_str + "' " + str(n) + "次")
    for i in range(n):
        print(i, input_str)

my_print(5, "Hello World!")
the_str = "開始學習 Python"
num = input("請輸入要列印的次數!")
my_print(int(num), the_str)
a = a + 1
print("(" + str(a) + ")", "_" * 25)

def myfun():
    yield 1
    yield 2
    yield 3

for i in myfun():
    print(i)

x = iter(myfun())
y = list(myfun())

a = a + 1
print("(" + str(a) + ")", "_" * 25)
print(x.__next__())
print(x.__next__())
print(x.__next__())
print(y)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex1" 的按鈕點按時, 執行 Ex1 物件中的 prog 方法
doc["ex1"].bind('click', Ex1.prog)
</script>
</p>
<p><!-- ***************************** slide ex1 end --></p>
<p><!-- ***************************** slide ex2 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex2 = beditor.editor("""# Python 的內建資料型別
import math
def f():
    print("This is a user-defined function")
    return 42

print("Some basic types in Python:")
print(type(2))           # int
print(type(2.2))         # float
print(type("2.2"))       # str  (string)
print(type(2 < 2.2))     # bool (boolean)
print(type(math))        # module
print(type(math.tan))    # builtin_function_or_method ("function" in Brython)
print(type(f))           # function (user-defined function)
print(type(type(42)))    # type

print("#####################################################")

print("And some other types we will see later in the course...")
print(type(Exception())) # Exception
print(type(range(5)))    # range
print(type([1,2,3]))     # list
print(type((1,2,3)))     # tuple
print(type({1,2}))       # set
print(type({1:42}))      # dict (dictionary or map)
print(type(2+3j))        # complex  (complex number) (we may not see this type)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex2" 的按鈕點按時, 執行 Ex2 物件中的 prog 方法
doc["ex2"].bind('click', Ex2.prog)
</script>
</p>
<p><!-- ***************************** slide ex2 end --></p>
<p><!-- ***************************** slide ex3 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex3 = beditor.editor("""# Python 的內建常數與函式
# 內建常數
print("Some builtin constants:")
print(True)
print(False)
print(None)

print("And some more constants in the math module:")
import math
print(math.pi)
print(math.e)
# 內建函式
print("Type conversion functions:")
print(bool(0))   # convert to boolean (True or False)
print(float(42)) # convert to a floating point number
print(int(2.8))  # convert to an integer (int)

print("And some basic math functions:")
print(abs(-5))   # absolute value
print(max(2,3))  # return the max value
print(min(2,3))  # return the min value
print(pow(2,3))  # raise to the given power (pow(x,y) == x**y)
print(round(2.354, 1)) # round with the given number of digits
# other examples
print(3 * 2)
print(3 * "abc")
print(3 + 2)
print("abc" + "def")
print(3 + "def")
# Type Affect Semantics
print(3 * 2)
print(3 * "abc")
print(3 + 2)
print("abc" + "def")
print(3 + "def")
# Integer Division
print("The / operator does 'normal' float division:")
print(" 5/3  =", ( 5/3))
print()
print("The // operator does integer division:")
print(" 5//3 =", ( 5//3))
print(" 2//3 =", ( 2//3))
print("-1//3 =", (-1//3))
print("-4//3 =", (-4//3))
# Modulus or Remainder Operator (%)
print(" 6%3 =", ( 6%3))
print(" 5%3 =", ( 5%3))
print(" 2%3 =", ( 2%3))
print(" 0%3 =", ( 0%3))
print("-4%3 =", (-4%3))
print(" 3%0 =", ( 3%0))
# Verify that (a%b) is equivalent to (a-(a//b)*b)
def mod(a, b):
  return a - (a//b)*b
print(41%14, mod(41,14))
print(14%41, mod(14,41))
print(-32%9, mod(-32,9))
print(32%-9, mod(32,-9))
# Operator Order (Precedence and Associativity)
print("Precedence:")
print(2+3*4)  # prints 14, not 20
print(5+4%3)  # prints  6, not 0 (% has same precedence as *, /, and //)
print(2**3*4) # prints 32, not 4096 (** has higher precedence than *, /, //, and %)

print()

print("Associativity:")
print(5-4-3)   # prints -2, not 4 (- associates left-to-right)
print(4**3**2) # prints 262144, not 4096 (** associates right-to-left)
# Approximate Values of Floating-Point Numbers
print(0.1 + 0.1 == 0.2)        # True, but...
print(0.1 + 0.1 + 0.1 == 0.3)  # False!
print(0.1 + 0.1 + 0.1)         # prints 0.30000000000000004 (uh oh)
print((0.1 + 0.1 + 0.1) - 0.3) # prints 5.55111512313e-17 (tiny, but non-zero!)
# Equality Testing with math.isclose
print("The problem....")
d1 = 0.1 + 0.1 + 0.1
d2 = 0.3
print(d1 == d2)                # False (never use == with floats!)

print()
print("The solution...")
import math
print(math.isclose(d1, d2))  # True!
# math.isclose checks if the two numbers are ALMOST equal, within a small error
# Short-Circuit Evaluation
def yes():
    return True

def no():
    return False

def crash():
    return 1/0 # crashes!

print(no() and crash()) # Works!
print(crash() and no()) # Crashes!
print (yes() and crash()) # Never runs (due to crash), but would also crash (without short-circuiting)
# Or operator
def yes():
    return True

def no():
    return False

def crash():
    return 1/0 # crashes!

print(yes() or crash()) # Works!
print(crash() or yes()) # Crashes!
print(no() or crash())  # Never runs (due to crash), but would also crash (without short-circuiting)
# more examples
def isPositive(n):
    result = (n > 0)
    print("isPositive(",n,") =", result)
    return result

def isEven(n):
    result = (n % 2 == 0)
    print("isEven(",n,") =", result)
    return result

print("Test 1: isEven(-4) and isPositive(-4))")
print(isEven(-4) and isPositive(-4)) # Calls both functions
print("----------")
print("Test 2: isEven(-3) and isPositive(-3)")
print(isEven(-3) and isPositive(-3)) # Calls only one function!
# type vs isinstance
# Both type and isinstance can be used to type-check
# In general, (isinstance(x, T)) will be more robust than (type(x) == T)

print(type("abc") == str)
print(isinstance("abc", str))

# We'll see better reasons for this when we cover OOP + inheritance later
# in the course.  For now, here is one reason:  say you wanted to check
# if a value is any kind of number (int, float, complex, etc). 
# You could do:

def isNumber(x):
    return ((type(x) == int) or
            (type(x) == float)) # are we sure this is ALL kinds of numbers?

print(isNumber(1), isNumber(1.1), isNumber(1+2j), isNumber("wow"))

# But this is cleaner, and works for all kinds of numbers, including
# complex numbers for example:

import numbers
def isNumber(x):
    return isinstance(x, numbers.Number) # works for any kind of number

print(isNumber(1), isNumber(1.1), isNumber(1+2j), isNumber("wow"))
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex3" 的按鈕點按時, 執行 Ex3 物件中的 prog 方法
doc["ex3"].bind('click', Ex3.prog)
</script>
</p>
<p><!-- ***************************** slide ex3 end --></p>
<p><!-- ***************************** slide ex4 start --></p>
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ex4 = beditor.editor("""# Python 函式
# Vocabulary
x = 5
def f(y, z):
    result = x + y + z
    return result
print(f(1, 2)) # 8
print(f(3, 4)) # 12

# Vocabulary:
#   variables: global vs. local
#   statements vs. expressions
#   function definitions vs. function calls
#   parameters vs. arguments

# Return Statements
# Basic example

def isPositive(x):
    return (x > 0)

print(isPositive(5))  # True
print(isPositive(-5)) # False
print(isPositive(0))  # False

# Return ends the function immediately
def isPositive(x):
    print("Hello!")   # runs
    return (x > 0)
    print("Goodbye!") # does not run ("dead code")

print(isPositive(5))  # prints Hello, then True

# No return statement --> return None
def f(x):
    x + 42

print(f(5)) # None

def f2(x):
    result = x + 42

print(f2(5)) # None

# Print versus Return
# This is a common early mistake (confusing print and return):
def cubed(x):
    print(x**3) # Here is the error!

cubed(2)          # seems to work!
print(cubed(3))   # sort of works (but prints None, which is weird)
print(2*cubed(4)) # Error!

# Once again (correctly)
def cubed2(x):
    return (x**3) # That's better!

cubed2(2)          # seems to be ignored (why?)
print(cubed2(3))   # works!
print(2*cubed2(4)) # works!

# Different Parameter and Return Types
def hypotenuse(a, b):
    return ((a**2) + (b**2))**0.5

print(hypotenuse(3, 4)) # 5.0 (not 5)
print("---------------------")

def xor(b1, b2):
    return ((b1 and (not b2)) or (b2 and (not b1)))  # same as (b1 != b2)

print(xor(True,  True))  # False
print(xor(True,  False)) # True
print(xor(False, True))  # True
print(xor(False, False)) # False
print("---------------------")

def isPositive(n):
    return (n > 0)

print(isPositive(10))     # True
print(isPositive(-1.234)) # False

# Function Composition
def f(w):
    return 10*w

def g(x, y):
    return f(3*x) + y

def h(z):
    return f(g(z, f(z+1)))

print(h(1)) # hint: try the "visualize" feature

# Helper Functions 
def onesDigit(n):
    return n%10

def largerOnesDigit(x, y):
    return max(onesDigit(x), onesDigit(y))

print(largerOnesDigit(134, 672)) # 4
print(largerOnesDigit(132, 674)) # Still 4

# Test Functions
# A broken test function
def onesDigit(n):
    return n%10

def testOnesDigit():
    print("Testing onesDigit()...", end="")
    assert(onesDigit(5) == 5)
    assert(onesDigit(123) == 3)
    assert(onesDigit(100) == 0)
    assert(onesDigit(999) == 9)
    print("Passed!")

testOnesDigit() # Passed!  Why is this bad?

# A better version
def onesDigit2(n):
    return n%10

def testOnesDigit2():
    print("Testing onesDigit()...", end="")
    assert(onesDigit2(5) == 5)
    assert(onesDigit2(123) == 3)
    assert(onesDigit2(100) == 0)
    assert(onesDigit2(999) == 9)
    assert(onesDigit2(-123) == 3) # Added this test
    print("Passed!")

testOnesDigit2() # Crashed!  So the test function worked!

# Local Variable Scope
def f(x):
    print("In f, x =", x)
    x += 5
    return x

def g(x):
    return f(x*2) + f(x*3)

print(g(2))

# Another example
def f(x):
    print("In f, x =", x)
    x += 7
    return round(x / 3)

def g(x):
    x *= 10
    return 2 * f(x)

def h(x):
    x += 3
    return f(x+4) + g(x)

print(h(f(1)))

# Global Variable Scope
# In general, you should avoid using global variables.
# You will even lose style points if you use them!
# Still, you need to understand how they work, since others
# will use them, and there may also be some very few occasions
# where you should use them, too!

g = 100

def f(x):
    return x + g

print(f(5)) # 105
print(f(6)) # 106
print(g)    # 100

# Another exampl
g = 100

def f(x):
    # If we modify a global variable, we must declare it as global.
    # Otherwise, Python will assume it is a local variable.
    global g
    g += 1
    return x + g

print(f(5)) # 106
print(f(6)) # 108
print(g)    # 102

# Default arguments
# Sometimes, a function has a parameter that has a natural default
# We can specify that default value in the function definition,
# then choose whether or not to include it in the function call.

def f(x, y=10):
    return x + y

print(f(5))   # 15
print(f(5,1)) # 6
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ex4" 的按鈕點按時, 執行 Ex4 物件中的 prog 方法
doc["ex4"].bind('click', Ex4.prog)
</script>
</p>
<p><!-- ***************************** slide ex4 end --></p>
<!-- line drawing start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Draw = beditor.editor("""# Line drawing
# 導入 doc
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 300, height = 200)
canvas.id = "line_drawing"
brython_div = doc["brython_div"]
brython_div <= canvas

# 準備繪圖畫布
canvas = doc["line_drawing"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
# 設定填圖顏色
ctx.fillStyle = "rgb(200,0,0)"
# 設定畫筆顏色
ctx.strokeStyle = "rgb(0,0,200)"
# 乘上 deg 可轉為徑度單位
deg = math.pi / 180

# 建立多邊形定點位置畫線函式
def star(radius, xc, yc, n):
    #radius = 100
    #xc = 200
    #yc = 200
    xi = xc + radius*math.cos((360/n)*deg+90*deg)
    yi = yc - radius*math.sin((360/n)*deg+90*deg)
    ctx.beginPath()
    ctx.moveTo(xi,yi)
    for i in range(2, n+1):
        x = xc + radius*math.cos((360/n)*deg*i+90*deg)
        y = yc - radius*math.sin((360/n)*deg*i+90*deg)
        ctx.lineTo(x,y)
# 以下利用多邊形畫線函式呼叫執行畫框線或填入顏色
# 畫五邊形框線
star(50, 50, 50, 5)
ctx.closePath()
ctx.stroke()
    
# 填三角形色塊
star(50, 150, 50, 3)
ctx.closePath()
ctx.fill()
    
# 改變畫線顏色後, 畫七邊形框線
ctx.strokeStyle = "rgb(0,200,20)"
star(50, 250, 50, 7)
ctx.closePath()
ctx.stroke()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "draw" 的按鈕點按時, 執行 Draw 物件中的 prog 方法
doc["draw"].bind('click', Draw.prog)
</script>
</p>
<!-- line drawing ends -->
<p></p>
<!-- flag ex start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Flag = beditor.editor("""# 畫中華民國國旗
# 導入 doc
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 300, height = 200)
canvas.style = {"width": "100%"}
canvas.id = "taiwan_flag"
brython_div = doc["brython_div"]
brython_div <= canvas

# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "flag" 的按鈕點按時, 執行 Flag 物件中的 prog 方法
doc["flag"].bind('click', Flag.prog)
</script>
</p>
<!-- flag ex ends -->
<p></p>
<!-- bunny start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Bunny = beditor.editor("""# Ggame
from ggame import App, ImageAsset, Sprite, MouseEvent
from random import random, randint
from browser import document as doc
from browser import html
import math

# 引入既有的id="graphics-column" 標註
graphics_column = doc["graphics-column"]
# 建立內定名稱為 "ggame-canvas" 的 canvas 標註
canvas = html.CANVAS(width = 600, height = 400)
canvas.id = "ggame-canvas"
# 將 canvas 插入 gc 標註中
graphics_column <= canvas


class Bunny(Sprite):
    
    asset = ImageAsset("/images/bunny.png")
    
    def __init__(self, position):
        super().__init__(Bunny.asset, position)
        # register mouse events
        App.listenMouseEvent(MouseEvent.mousedown, self.mousedown)
        App.listenMouseEvent(MouseEvent.mouseup, self.mouseup)
        App.listenMouseEvent(MouseEvent.mousemove, self.mousemove)
        self.dragging = True
        self.deltax = 0
        self.deltay = 0

    
    def step(self):
        # Every now and then a bunny hops...
        if random() < 0.01:
            self.x += randint(-20,20)
            self.y += randint(-20,20)
        
        
    def mousedown(self, event):
        # capture any mouse down within 50 pixels
        self.deltax = event.x - (self.x + self.width//2) 
        self.deltay = event.y - (self.y + self.height//2)
        if abs(self.deltax) < 50 and abs(self.deltay) < 50:
            self.dragging = True
            # only drag one bunny at a time - consume the event
            event.consumed = True
            
    def mousemove(self, event):
        if self.dragging:
            self.x = event.x - self.deltax - self.width//2
            self.y = event.y - self.deltay - self.height//2
            event.consumed = True
            
    def mouseup(self, event):
        if self.dragging:
            self.dragging = False
            event.consumed = True
            
        
class DemoApp(App):
    
    def __init__(self):
        super().__init__()
        for i in range(5):
            Bunny((randint(50, 600), randint(50, 400)))
        
    def step(self):
        # Override step to perform action on each frame update
        for bunny in self.spritelist:
            bunny.step()


# Create the app
app = DemoApp()  
# Run the app
app.run()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "bunny" 的按鈕點按時, 執行 Bunny 物件中的 prog 方法
doc["bunny"].bind('click', Bunny.prog)
</script>
</p>
<!-- bunny ends -->
<p></p>
<!-- clear canvas start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Clear = beditor.editor("""# 清除畫布
from browser import document, html
brython_div = document["brython_div"] 
brython_div.clear()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "clear" 的按鈕點按時, 執行 Clear 物件中的 prog 方法
doc["clear"].bind('click', Clear.prog)
</script>
</p>
<!-- clear canvas ends -->
<p></p>
<!-- cango spur gears start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Spur = beditor.editor("""# Cango Spur Gears
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 600, height = 400)
canvas.id = "cango_gear"
brython_div = doc["brython_div"]
brython_div <= canvas
from browser import document as doc
from browser import window
import math

canvas = doc["cango_gear"]
# 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx
#ctx = canvas.getContext("2d")
cango = window.Cango.new
# 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換
shapedefs = window.shapeDefs
shape = window.Shape.new
path = window.Path.new
creategeartooth = window.createGearTooth.new

tweener = window.Tweener.new
# 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id="cango_gear" 的 canvas 上
cgo = cango("cango_gear")

######################################
# 畫正齒輪輪廓
#####################################
def cangoGear(n, m, pa):
    # n 為齒數
    #n = 17
    # pa 為壓力角
    #pa = 25
    # m 為模數, 根據畫布的寬度, 計算適合的模數大小
    # Module = mm of pitch diameter per tooth
    #m = 0.8*canvas.width/n
    # pr 為節圓半徑
    pr = n*m/2 # gear Pitch radius
    # generate gear
    data = creategeartooth(m, n, pa)
    # Brython 程式中的 print 會將資料印在 Browser 的 console 區
    #print(data)
    gearTooth = path(data, {
      "fillColor":"#ddd0dd",
      "border": True,
      "strokeColor": "#606060" })
    gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh
    # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中
    gear = gearTooth.dup()
    # gear 為單一齒的輪廓資料
    #cgo.render(gearTooth)

    # 利用單齒輪廓旋轉, 產生整個正齒輪外形
    for i in range(1, n):
        # 將 gearTooth 中的資料複製到 newTooth
        newTooth = gearTooth.dup()
        # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear
        newTooth.rotate(360*i/n)
        gear.appendPath(newTooth)
    # 建立軸孔
    # add axle hole, hr 為 hole radius
    hr = 0.6*pr # diameter of gear shaft
    shaft = path(shapedefs.circle(hr), {
      "fillColor":"#ddd0dd",
      "border": True,
      "strokeColor": "#606060" })
    gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path
    return gear

# 設定兩齒齒數
n1 = 17
n2 = 11
n3 = 13
reduced_ratio = 0.5
# 使用 80% 的畫布寬度
m = 0.8*canvas.width/((n1+n2+n3)*reduced_ratio)
# 設定共同的壓力角
pa = 25
# n 齒輪的節圓半徑
pr1 = n1*m/2
# n2 齒輪的節圓半徑
pr2 = n2*m/2
pr3 = n3*m/2

cx = canvas.width/2
cy = canvas.height/2
# 建立 gears
gear1 = cangoGear(n1, m, pa)
gear2 = cangoGear(n2, m, pa)
gear3 = cangoGear(n3, m, pa)

from browser.timer import set_interval

deg = math.pi/180
rotate_speed = 12*deg

def draw():
    cgo.clearCanvas()
    gear1.transform.translate(cx-(pr1+pr2)*reduced_ratio, cy)
    gear1.transform.scale(reduced_ratio)
    gear1.transform.rotate(0)
    gear1.rotate(rotate_speed)
    cgo.render(gear1)
    
    gear2.transform.translate(cx, cy)
    gear2.transform.scale(reduced_ratio)
    gear2.transform.rotate(180+(360/n2/2))
    gear2.rotate(-(rotate_speed)*n1/n2)
    cgo.render(gear2)
    
    gear3.transform.translate(cx+(pr2+pr3)*reduced_ratio, cy)
    gear3.transform.scale(reduced_ratio)
    gear3.transform.rotate(180+(360/n3/2)+(180+(360/n2/2))*n2/n3)
    gear3.rotate((rotate_speed*n1/n2)*(n2/n3))
    cgo.render(gear3)

set_interval(draw, 2)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "spur" 的按鈕點按時, 執行 Spur 物件中的 prog 方法
doc["spur"].bind('click', Spur.prog)
</script>
</p>
<!-- cango spur gears ends -->
<p></p>
<!-- temp convert start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Temp = beditor.editor("""# Temperature Conversion
# Temperature Conversion
'''
C to F: Celsius to Fahrenheit Conversion Formula. To convert temperatures in degrees Celsius to Fahrenheit, multiply by 1.8 (or 9/5) and add 32.

To convert temperatures in degrees Fahrenheit to Celsius, subtract 32 and multiply by .5556 (or 5/9).

Fahrenheit = Celsius*9/5 + 32

Celsium = (Fahrenheit - 32)*5/9
'''
from browser import document, html
brython_div = document["brython_div"]

def c2f(c):
    f = round(c*9/5 + 32, 3)
    return "Celsiusc: "+ str(c) +         " degrees = Fahrenheit: " + str(f) + " degrees"
    
def f2c(f):
    c = round((f - 32)*5/9, 3)
    return "Fahrenheit: "+ str(f) +         " degrees = Celsiusc: " + str(c) + " degrees"
    
choice = input("c2f or f2c")
if choice == "c2f":
    '''
    c = float(input("input Celsius in degrees"))
    print(c2f(c))
    '''
    for deg in range(100):
        brython_div <= c2f(deg)
        brython_div <= html.BR()
else:
    '''
    f = float(input("input Fahrenheit in degrees"))
    print(f2c(f))
    '''
    for deg in range(100):
        brython_div <= f2c(deg)
        brython_div <= html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "temp" 的按鈕點按時, 執行 Temp 物件中的 prog 方法
doc["temp"].bind('click', Temp.prog)
</script>
</p>
<!-- temp convert ends -->
<p></p>
<!-- forloop start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Forloop = beditor.editor("""# For loop
for i in range(5):
    print(i)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "forloop" 的按鈕點按時, 執行 Forloop 物件中的 prog 方法
doc["forloop"].bind('click', Forloop.prog)
</script>
</p>
<!-- forloop ends -->
<p></p>
<!-- guess start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Guess = beditor.editor("""# 猜數字遊戲
from browser import document, html, alert
import random

# 跳出文字說明視窗
alert("開始玩猜數字遊戲")
# 利用 random 模組中的 randint 取 1~100 間的亂數
標準答案 = random.randint(1, 100)
# 利用 input 函式視窗, 取使用者所猜的數字, 轉為整數
你猜的數字 = int(input("請輸入您所猜 1~100 間的整數:"))
# 猜測次數起始值設為 1
猜測次數 = 1
# 進入重複迴圈, 直到猜對數字
while 標準答案 != 你猜的數字:
    # 根據使用者所猜的數字, 與答案比較後, 給出提示
    if 標準答案 < 你猜的數字:
        alert("猜第" + str(猜測次數) + "次, 太大了，再猜 :)加油")
    else:
        alert("猜第" + str(猜測次數) + "次, 太小了，再猜 :)加油")
    你猜的數字 = int(input("請輸入您所猜 1~100 間的整數:"))
    # 猜測次數累加
    猜測次數 += 1

# 跳出迴圈表示猜對, 給出最後文字說明視窗
alert("猜對了！答案為" + str(標準答案) + ", 總共猜了" + str(猜測次數) + "次")
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "guess" 的按鈕點按時, 執行 Guess 物件中的 prog 方法
doc["guess"].bind('click', Guess.prog)
</script>
</p>
<!-- guess ends -->
<p></p>
<!-- autoguess start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Autoguess = beditor.editor("""# 程式自動猜數字遊戲
from browser import document, html, alert
import random
 
id4 = document["brython_div"]

執行次數 = 100
總猜測次數 = 0
for i in range(執行次數):
    id4 <= "第" + str(i+1) + "次玩:" + html.BR()
    下限 = 1
    上限 = 100
    標準答案 = random.randint(下限, 上限)
    pc猜的數字 = random.randint(下限, 上限)
    #print(標準答案, pc猜的數字)
    #integer int()
    #string str()
    #float float()
    #你猜的數字 = int(input("請輸入您所猜的整數:"))
    猜測次數 = 1
    while 標準答案 != pc猜的數字:
        if 標準答案 < pc猜的數字:
            #print("太大了，再猜一次 :)加油")
            # 因此已經確定"pc猜的數字"不是答案, 因此 - 1
            id4 <= "電腦猜的數字:" + str(pc猜的數字) + " 太大了!" + html.BR()
            上限 = pc猜的數字 - 1
        else:
            #print("太小了，再猜一次 :)加油")
            # 因此已經確定"pc猜的數字"不是答案, 因此 + 1
            id4 <= "電腦猜的數字:" + str(pc猜的數字) + " 太小了!" + html.BR()
            下限 = pc猜的數字 + 1
        #pc猜的數字 = int(input("請輸入您所猜的整數:"))
        pc猜的數字 = random.randint(下限, 上限)
        猜測次數 += 1

    #print("猜對了！總共猜了", 猜測次數, "次")
    id4 <= "電腦猜對了, 答案為: " + str(標準答案) + ", 總共猜了 "+ str(猜測次數) + "次" + html.BR()
    總猜測次數 += 猜測次數

平均猜測次數 = int(總猜測次數/執行次數)
#print("平均次數", 平均猜測次數)
id4 <= "平均次數: " + str(平均猜測次數)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "autoguess" 的按鈕點按時, 執行 Autoguess 物件中的 prog 方法
doc["autoguess"].bind('click', Autoguess.prog)
</script>
</p>
<!-- autoguess ends -->
<p></p>
<!-- lottery start -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Lottery = beditor.editor("""# 大樂透電腦選號
# lottery
from browser import document, html, alert
import random

try:
    total = int(input("請問要出幾張彩卷號碼?"))
except:
    alert("請輸入要選擇電腦選號數量的'整數'")
    total = int(input("請問要出幾張彩卷號碼?"))

# 準備將電腦選出的號碼, 輸出到內定 id="brython_div" 的標註區域
output_div = document["brython_div"]
output_div <= "以下將出 " + str(total) + " 張電腦選號彩卷:" + html.BR()
for i in range(1, total + 1):
    # 利用 list(range()) 產生 1 到 49 的 population list
    # 然後再透過 random.sample(population, k) 
    # 從 population, 產生 k 個不同的數字
    numbers = random.sample(list(range(1, 49)), 6)
    output_div <= str(i) + ". 電腦選號為: " + str(numbers) + html.BR()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "lottery" 的按鈕點按時, 執行 Lottery 物件中的 prog 方法
doc["lottery"].bind('click', Lottery.prog)
</script>
</p>
<!-- lottery ends -->
<p></p>
<!-- bezier starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Bezier = beditor.editor("""# Cango Bezier 繪圖
from browser import window, html
from browser import document as doc

canvas = html.CANVAS(width = 600, height = 400)
canvas.id = "canvas"
brython_div = doc["brython_div"]
brython_div <= canvas

# Javascript 物件
cango = window.Cango.new
path = window.Path.new
shape = window.Shape.new
group = window.Group.new
# Javascript 變數
shapedefs = window.shapeDefs
g1 = cango("canvas")
g1.clearCanvas()
g1.gridboxPadding(10, 10, 5, 7)
g1.fillGridbox("lightgreen")
g1.setWorldCoordsRHC(-100, -100, 400)

x1 = 40
y1 = 20
cx1 = 90
cy1 = 120
x2 = 120
y2 = 100
cx2 = 130
cy2 = 20
cx3 = 150
cy3 = 120
x3 = 180
y3 = 60

def dragC1(mousePos):
    global cx1, cy1
    cx1 = mousePos.x
    cy1 = mousePos.y
    drawCurve()

def dragC2(mousePos):
    global cx2, cy2
    cx2 = mousePos.x
    cy2 = mousePos.y
    drawCurve()

def dragC3(mousePos):
    global cx3, cy3
    cx3 = mousePos.x
    cy3 = mousePos.y
    drawCurve()

def drawCurve():
    qbez = path(['M', x1, y1, 'Q', cx1, cy1, x2, y2], {
      'strokeColor':'blue'})
    cbez = path(['M', x2, y2, 'C', cx2, cy2, cx3, cy3, x3, y3], {
      'strokeColor':'green'})
    L1 = path(['M', x1, y1, 'L', cx1, cy1, x2, y2], {
      'strokeColor':"rgba(0, 0, 0, 0.2)",
      'dashed':[4]})
    L2 = path(['M', x2, y2, 'L', cx2, cy2], {
      'strokeColor':"rgba(0, 0, 0, 0.2)",
      'dashed':[4]})
    L3 = path(['M', x3, y3, 'L', cx3, cy3], {
      'strokeColor':"rgba(0, 0, 0, 0.2)",
      'dashed':[4]})
    c1.transform.translate(cx1, cy1)
    c2.transform.translate(cx2, cy2)
    c3.transform.translate(cx3, cy3)
    grp = group(qbez, cbez, L1, L2, L3, c1, c2, c3)
    g1.render(grp, True)

g1.clearCanvas("lightyellow")
g1.deleteAllLayers()
g1.setWorldCoordsRHC(0, 0, 200)

c1 = shape(shapedefs.circle(6), {'fillColor':'red'})
c1.enableDrag(None, dragC1, None)

c2 = shape(shapedefs.circle(6), {'fillColor':'red'})
c2.enableDrag(None, dragC2, None)

c3 = shape(shapedefs.circle(6), {'fillColor':'red'})
c3.enableDrag(None, dragC3, None);

drawCurve()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "bezier" 的按鈕點按時, 執行 Bezier 物件中的 prog 方法
doc["bezier"].bind('click', Bezier.prog)
</script>
</p>
<!-- bezier ends -->
<p></p>
<!-- turtle1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle1 = beditor.editor("""# Turtle1 繪圖
from browser import window, html
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle()

t.width(5)

for c in ['red', '#00ff00', '#fa0', 'rgb(0,0,200)']:
    t.color(c)
    t.forward(100)
    t.left(90)

# dot() and write() do not require the pen to be down
t.penup()
t.goto(-30, -100)
t.dot(40, 'rgba(255, 0, 0, 0.5')
t.goto(30, -100)
t.dot(40, 'rgba(0, 255, 0, 0.5')
t.goto(0, -70)
t.dot(40, 'rgba(0, 0, 255, 0.5')

t.goto(0, 125)
t.color('purple')
t.write("這就是 Brython, 網頁上的 Python", font=("Arial", 15, "normal"))

turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle1" 的按鈕點按時, 執行 Turtle1 物件中的 prog 方法
doc["turtle1"].bind('click', Turtle1.prog)
</script>
</p>
<!-- turtle1 ends -->
<p></p>
<!-- turtle2 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle2 = beditor.editor("""# Turtle2 繪圖
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
star = turtle.Turtle()

for i in range(5):
    star.forward(250)
    star.right(144)
    
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle2" 的按鈕點按時, 執行 Turtle2 物件中的 prog 方法
doc["turtle2"].bind('click', Turtle2.prog)
</script>
</p>
<!-- turtle2 ends -->
<p></p>
<!-- turtle3 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle3 = beditor.editor("""# Turtle3 繪圖
# https://michael0x2a.com/blog/turtle-examples
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
painter = turtle.Turtle()

painter.pencolor("blue")

for i in range(50):
    painter.forward(50)
    painter.left(123) # Let's go counterclockwise this time 
    
painter.pencolor("red")
for i in range(50):
    painter.forward(100)
    painter.left(123)
    
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle3" 的按鈕點按時, 執行 Turtle3 物件中的 prog 方法
doc["turtle3"].bind('click', Turtle3.prog)
</script>
</p>
<!-- turtle3 ends -->
<p></p>
<!-- turtle4 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle4 = beditor.editor("""# Turtle4 繪圖
# https://docs.python.org/3.7/library/turtle.html?highlight=turtle
# https://fiftyexamples.readthedocs.io/en/latest/turtle.html
from browser import document as doc
import turtle
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
# 輸入 "turtle" 字串, 表示要使用內建的烏龜圖示
t = turtle.Turtle("turtle")

# 設定繪圖尺寸
screen_x = 500-20
screen_y = 300

# 提筆, 將烏龜移動到畫布中心
t.penup()
t.home()

# 內定方向為右, 前進 screen_x/2
t.forward(screen_x / 2)
# 將方向往右轉 90 度
t.right(90)
# 此時方向向下, 前進 screen_y/2
t.forward(screen_y / 2)
# 令烏龜方向轉絕對角度 180, 等同轉相對角度 90 度, 即 t.right(90)
t.setheading(180)

# 將畫筆顏色設為紅色
t.pencolor('red')
# 下筆準備繪圖
t.pendown()
# 設筆寬度為 10
t.pensize(10)
# 進入重複迴圈, 此時方向向右, 分別
# 前進 screen_x, 之後轉 90 度, 方向朝上
# 再前進 screen_y, 之後再轉 90 度, 方向朝右
# 再前進 screen_x, 之後轉 90 度, 方向朝下
# 最後再前進 screen_y 後, 將方向轉為向左
for distance in (screen_x, screen_y, screen_x, screen_y):
    t.forward(distance)
    t.right(90)

# 提筆後, 將烏龜轉回內定方向回到畫布中心
t.penup()
t.home()
# 完成 turtle 繪圖
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle4" 的按鈕點按時, 執行 Turtle4 物件中的 prog 方法
doc["turtle4"].bind('click', Turtle4.prog)
</script>
</p>
<!-- turtle4 ends -->
<p></p>
<!-- turtle5 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle5 = beditor.editor("""# Turtle5 繪圖
# https://brython.info/gallery/turtle.html
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
t = turtle.Turtle("turtle")
t.speed(1)
t.forward(50)

print("Should be (50, 0):", t.position())
print("Should be 50: ", t.xcor())
print("Should be 0: ", t.ycor())

t.left(90)
t.color("blue")
t.speed(2)
t.fd(50)

print("Should be (50, 50):", t.pos())
print("Should be 225: ", t.towards(0, 0))
print("Should be 90: ", t.heading())
print("Should be approximately 71:", t.distance(0, 0))

# Draw the same square in three different angle modes
t.width(4)

print("Drawing using degrees - the default")
print("Heading should be 90: ", t.heading())

for i in range(4):
    t.forward(100)
    t.left(90)

print("Drawing using radians")

t.radians()

print("Heading should be pi/2: ", t.heading())

for i in range(4):
    t.forward(100)
    t.left(math.pi/2)

print("Drawing using gradients")

t.degrees(400)

print("Heading should be 100: ", t.heading())

for i in range(4):
    t.forward(100)
    t.left(100)

t.degrees()
t.width(1)

t.lt(90)
t.color("orange")
t.backward(50)
t.right(90)
t.color("green")
t.back(50)
t.rt(90)
t.color("red")
t.bk(50)
t.stamp()
t.speed(4)

t.color("black", "white")
t.goto(-100, 100)
t.stamp()
t.color("blue", "yellow")
t.setposition(0, 100)
t.stamp()
t.color("green", "white")
t.setpos(100, 100)
t.stamp()

t.speed(10)
t.color("orange")
t.sety(-100)
t.setx(-100)
t.stamp()

t.color("cyan")
t.home()
t.stamp()

t.color("green")
t.width(4)
t.setheading(180)
t.forward(150)
t.seth(90)
t.fd(20)

t.dot(30, "rgba(255, 0, 0, 0.2)")
t.color("red")
t.speed(0)
t.forward(30)
t.left(90)
t.circle(30)

turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle5" 的按鈕點按時, 執行 Turtle5 物件中的 prog 方法
doc["turtle5"].bind('click', Turtle5.prog)
</script>
</p>
<!-- turtle5 ends -->
<p></p>
<!-- turtle6 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle6 = beditor.editor("""# Turtle6 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)

t = turtle.Turtle("turtle")
t.speed(10)

colors = ['red', 'purple', 'blue', 'green', 'orange']
for x in range(150):
    t.pencolor(colors[x % 5])
    t.width(x/10 + 1)
    t.forward(x)
    t.left(59)
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle6" 的按鈕點按時, 執行 Turtle6 物件中的 prog 方法
doc["turtle6"].bind('click', Turtle6.prog)
</script>
</p>
<!-- turtle6 ends -->
<p></p>
<!-- turtle7 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle7 = beditor.editor("""# Turtle7 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)

screen=turtle.Screen()    #making a canvas for drawing
screen.bgcolor('black')    #making canvas black

trtl=turtle.Turtle()  #making a turtle

trtl.pencolor('red')    #making colour of the pen red
trtl.pensize(5)    #choosing the size of pen nib 
trtl.speed(10)    #choosing the speed of drawing
# shape should be ‘arrow’, ‘classic’, ‘turtle’ or ‘circle’
trtl.shape('turtle')   #choosing the shape of pen nib
trtl.forward(150)    #drawing a line of 150 pixels
trtl.right(90)    #asking turtle to turn 90 degrees
trtl.forward(150)    #drawing a line of 150 pixels
trtl.penup()    # preparing for moving pen without drawing
trtl.setpos(-140,-120)    # making the new position of the turtle
trtl.pendown()   # bringing the pen down for drawing again
trtl.pencolor('green')    # choosin the pen colour as green
trtl.write('Brython 烏龜繪圖', font=("Arial", 20, "bold"))    # chosing the font
trtl.penup()
trtl.ht()    # hiding the turtle from the screen
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle7" 的按鈕點按時, 執行 Turtle7 物件中的 prog 方法
doc["turtle7"].bind('click', Turtle7.prog)
</script>
</p>
<!-- turtle7 ends -->
<p></p>
<!-- turtle8 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Turtle8 = beditor.editor("""# Turtle8 繪圖
from browser import document as doc
import turtle
import math
turtle.set_defaults(
    turtle_canvas_wrapper = doc['brython_div']
)
wn = turtle.Screen() 
wn.bgcolor("black") 

skk = turtle.Turtle() 
skk.speed(10)
skk.shape("circle")
skk.color("blue") 
  
def sqrfunc(size): 
    for i in range(4): 
        skk.fd(size) 
        skk.left(90) 
        size = size-5
  
sqrfunc(146) 
sqrfunc(126) 
sqrfunc(106) 
sqrfunc(86) 
sqrfunc(66) 
sqrfunc(46) 
sqrfunc(26) 
turtle.done()
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "turtle8" 的按鈕點按時, 執行 Turtle8 物件中的 prog 方法
doc["turtle8"].bind('click', Turtle8.prog)
</script>
</p>
<!-- turtle8 ends -->
<p></p>
<!-- konva1 starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Konva1 = beditor.editor("""# Konva1 繪圖
# 引用 https://konvajs.github.io/ 繪圖
from browser import document, html, window

width = 600
height = 400

konva = window.Konva
# Konva 必須在 canvas 繪圖, 從上方設定,  canvas id 為 "container"
stage = konva.Stage.new({
        "container": 'brython_div',
        "width": width,
        "height": height
    })

layer = konva.Layer.new()
rectX = stage.getWidth() / 2 - 50
rectY = stage.getHeight() / 2 - 25

box = konva.Rect.new({
        "x": rectX,
        "y": rectY,
        "width": 100,
        "height": 50,
        "fill": '#00D2FF',
        "stroke": 'black',
        "strokeWidth": 4,
        "draggable": True
    })

def f1():
    document.body.style.cursor = 'pointer'
    
def f2():
    document.body.style.cursor = 'default'

# add cursor styling
box.on('mouseover', f1())
box.on('mouseout', f2())

layer.add(box)
stage.add(layer)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "konva1" 的按鈕點按時, 執行 Konva1 物件中的 prog 方法
doc["konva1"].bind('click', Konva1.prog)
</script>
</p>
<!-- konva1 ends -->
<p></p>
<!-- ycqsort starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ycqsort = beditor.editor("""# Ycombinator quicksort example
Y = lambda f: lambda *args: f(Y(f))(*args)

quicksort = Y(lambda f:
    lambda x: (
        f([item for item in x if item < x[0]])
        + [y for y in x if x[0] == y]
        + f([item for item in x if item > x[0]])
    ) if x else [])
    
print(quicksort([1, 3, 5, 4, 1, 3, 2]))
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ycqsort" 的按鈕點按時, 執行 Ycqsort 物件中的 prog 方法
doc["ycqsort"].bind('click', Ycqsort.prog)
</script>
</p>
<!-- ycqsort ends -->
<p></p>
<!-- ball starts -->
<p>
<script type="text/python3">
from browser import document as doc
import beditor
Ball = beditor.editor("""# Ggame ball example
from ggame import (
    App, 
    Color, 
    LineStyle, 
    Sprite, 
    RectangleAsset, 
    ImageAsset,
    CircleAsset, 
    EllipseAsset, 
    PolygonAsset,
)
from browser import document as doc
from browser import html

# 引入既有的id="graphics-column" 標註
graphics_column = doc["graphics-column"]
# 建立內定名稱為 "ggame-canvas" 的 canvas 標註
canvas = html.CANVAS(width = 600, height = 100)
canvas.id = "ggame-canvas"
# 將 canvas 插入 gc 標註中
graphics_column <= canvas

# reverse - change the ball direction
def reverse(b):
    b.direction *= -1

# Set up function for handling screen refresh
def step():
    if ball.go:
        ball.x += ball.direction
        if ball.x + ball.width > myapp.width or ball.x < 0:
            ball.x -= ball.direction
            reverse(ball)

myapp = App()
# Three primary colors with no transparency (alpha = 1.0)
red = Color(0xff0000, 1.0)
green = Color(0x00ff00, 1.0)
blue = Color(0x0000ff, 1.0)
black = Color(0x000000, 1.0)
# define colors and line style
green = Color(0x00ff00, 1)
black = Color(0, 1)
noline = LineStyle(0, black)
# a rectangle asset and sprite to use as background
bg_asset = RectangleAsset(canvas.width, canvas.height, noline, green)
bg = Sprite(bg_asset, (0,0))
ball_asset = ImageAsset("/images/orb-150545_640.png")
ball = Sprite(ball_asset, (0, 0))
# Original image is too big. Scale it to 1/10 its original size
ball.scale = 0.1
# custom attributes
ball.direction = 7
ball.go = True
myapp.run(step)
""", "kw_editor", "kw_console", "kw__container", "kw_py_src")
# id 為 "ball" 的按鈕點按時, 執行 Ball 物件中的 prog 方法
doc["ball"].bind('click', Ball.prog)
</script>
</p>
<!-- ball ends -->
<p><button id="keyword">Keyword</button><button id="ex1">Ex1</button><button id="ex2">Ex2</button><button id="ex3">Ex3</button><button id="ex4">Ex4</button><button id="forloop">Ex5</button><button id="guess">Guess</button><button id="autoguess">Autoguess</button><button id="lottery">Lottery</button><button id="temp">Temp</button><button id="draw">Draw</button><button id="flag">Flag</button><button id="bezier">Bezier</button><button id="turtle1">Turtle1</button><button id="turtle2">Turtle2</button><button id="turtle3">Turtle3</button><button id="turtle4">Turtle4</button><button id="turtle5">Turtle5</button><button id="turtle6">Turtle6</button><button id="turtle7">Turtle7</button><button id="turtle8">Turtle8</button><button id="konva1">Konva1</button><button id="bunny">Bunny</button><button id="ball">Ball</button><button id="spur">Spur</button><button id="ycqsort">Ycqsort</button><button id="clear">Clear</button></p>
<h4>參考資料:</h4>
<p><a href="/downloads/turtle_intro.pdf">turtle_intro.pdf</a></p>
<p><a href="/downloads/turtle_intro2.pdf">turtle_intro2.pdf</a></p>
<p>其他擷取程式的方式: <a href="http://mde.tw/2017springvcp/blog/web-based-python.html">http://mde.tw/2017springvcp/blog/web-based-python.html</a> </p>
<h1>Qt for Python</h1>
<p><a href="https://www.qt.io/qt-for-python">https://www.qt.io/qt-for-python</a> </p>
<p><a href="https://build-system.fman.io/python-qt-tutorial">https://build-system.fman.io/python-qt-tutorial</a> </p>
<p><a href="https://build-system.fman.io/pyqt-exe-creation/">https://build-system.fman.io/pyqt-exe-creation/</a> </p>
<p><a href="https://github.com/mherrmann/fbs-tutorial">https://github.com/mherrmann/fbs-tutorial</a> </p>
<p><a href="https://www.ics.com/blog/we-ported-qt-app-c-python-heres-what-happened">https://www.ics.com/blog/we-ported-qt-app-c-python-heres-what-happened</a> </p>
<p>
<script src="/static/konva.min.js"></script>
</p>
<div id="container"></div>
<p>
<script>
    var width = window.innerWidth;
    var height = window.innerHeight;

    // globals
    var curveLayer, lineLayer, anchorLayer, quad, bezier;

    function updateDottedLines() {
        var q = quad;
        var b = bezier;

        var quadLine = lineLayer.get('#quadLine')[0];
        var bezierLine = lineLayer.get('#bezierLine')[0];

        quadLine.setPoints([q.start.attrs.x, q.start.attrs.y, q.control.attrs.x, q.control.attrs.y, q.end.attrs.x, q.end.attrs.y]);

        bezierLine.setPoints([b.start.attrs.x, b.start.attrs.y, b.control1.attrs.x, b.control1.attrs.y, b.control2.attrs.x, b.control2.attrs.y, b.end.attrs.x, b.end.attrs.y]);
        lineLayer.draw();
    }
    function buildAnchor(x, y) {
        var anchor = new Konva.Circle({
            x: x,
            y: y,
            radius: 20,
            stroke: '#666',
            fill: '#ddd',
            strokeWidth: 2,
            draggable: true
        });

        // add hover styling
        anchor.on('mouseover', function() {
            document.body.style.cursor = 'pointer';
            this.setStrokeWidth(4);
            anchorLayer.draw();
        });
        anchor.on('mouseout', function() {
            document.body.style.cursor = 'default';
            this.setStrokeWidth(2);
            anchorLayer.draw();

        });

        anchor.on('dragend', function() {
            drawCurves();
            updateDottedLines();
        });

        anchorLayer.add(anchor);
        return anchor;
    }
    function drawCurves() {
        var context = curveLayer.getContext();

        context.clear();

        // draw quad
        context.beginPath();
        context.moveTo(quad.start.attrs.x, quad.start.attrs.y);
        context.quadraticCurveTo(quad.control.attrs.x, quad.control.attrs.y, quad.end.attrs.x, quad.end.attrs.y);
        context.setAttr('strokeStyle', 'red');
        context.setAttr('lineWidth', 4);
        context.stroke();

        // draw bezier
        context.beginPath();
        context.moveTo(bezier.start.attrs.x, bezier.start.attrs.y);
        context.bezierCurveTo(bezier.control1.attrs.x, bezier.control1.attrs.y, bezier.control2.attrs.x, bezier.control2.attrs.y, bezier.end.attrs.x, bezier.end.attrs.y);
        context.setAttr('strokeStyle', 'blue');
        context.setAttr('lineWidth', 4);
        context.stroke();
    }

    var stage = new Konva.Stage({
        container: 'container',
        width: width,
        height: height
    });

    anchorLayer = new Konva.Layer();
    lineLayer = new Konva.Layer();

    // curveLayer just contains a canvas which is drawn
    // onto with the existing canvas API
    curveLayer = new Konva.Layer();

    var quadLine = new Konva.Line({
        dash: [10, 10, 0, 10],
        strokeWidth: 3,
        stroke: 'black',
        lineCap: 'round',
        id: 'quadLine',
        opacity: 0.3,
        points: [0, 0]
    });

    var bezierLine = new Konva.Line({
        dash: [10, 10, 0, 10],
        strokeWidth: 3,
        stroke: 'black',
        lineCap: 'round',
        id: 'bezierLine',
        opacity: 0.3,
        points: [0, 0]
    });

    // add dotted line connectors
    lineLayer.add(quadLine);
    lineLayer.add(bezierLine);

    quad = {
        start: buildAnchor(60, 30),
        control: buildAnchor(240, 110),
        end: buildAnchor(80, 160)
    };

    bezier = {
        start: buildAnchor(280, 20),
        control1: buildAnchor(530, 40),
        control2: buildAnchor(480, 150),
        end: buildAnchor(300, 150)
    };

    // keep curves insync with the lines
    anchorLayer.on('beforeDraw', function() {
        drawCurves();
        updateDottedLines();
    });



    stage.add(curveLayer);
    stage.add(lineLayer);
    stage.add(anchorLayer);

    drawCurves();
    updateDottedLines();
  </script>
</p>
<h1>Math</h1>
<h4>Basic algebra concept (代數)</h4>
<p><a href="https://www.ck12.org/book/CK-12-Basic-Algebra-Concepts/">https://www.ck12.org/book/CK-12-Basic-Algebra-Concepts/</a>  (K-12 教材)</p>
<p>數學教材: <a href="https://openstax.org/subjects/math">https://openstax.org/subjects/math</a> </p>
<p>Pre algebra: <a href="https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/Prealgebra-OP_7D9i20P.pdf">https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/Prealgebra-OP_7D9i20P.pdf</a> </p>
<p>Elementary algebra: <a href="https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/ElementaryAlgebra-OP_71KfFB6.pdf">https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/ElementaryAlgebra-OP_71KfFB6.pdf</a> </p>
<p>Intermedia algebra: <a href="https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/IntermediateAlgebra-OP_dzG9dw4.pdf">https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/IntermediateAlgebra-OP_dzG9dw4.pdf</a> </p>
<p>Algebra and trigonometry: <a href="https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/AlgebraAndTrigonometry-OP_hyusk2X.pdf">https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/AlgebraAndTrigonometry-OP_hyusk2X.pdf</a> </p>
<p>Colege algebra: <a href="https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/CollegeAlgebra-OP_s3hAxEt.pdf">https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/CollegeAlgebra-OP_s3hAxEt.pdf</a> </p>
<p>Calculus Vol. 1: <a href="https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/CalculusVolume1-OP.pdf">https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/CalculusVolume1-OP.pdf</a> </p>
<p>Calculus Vol. 2: <a href="https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/CalculusVolume2-OP_7nNwGJD.pdf">https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/CalculusVolume2-OP_7nNwGJD.pdf</a></p>
<p>Calculus Vol. 3: <a href="https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/CalculusVolume3-OP.pdf">https://d3bxy9euw4e147.cloudfront.net/oscms-prodcms/media/documents/CalculusVolume3-OP.pdf</a> </p>
<h4>數學與電腦程式相同, 都是溝通用的語言</h4>
<p>語言的學習, 只有開始, 沒有結束, 必須終身學習</p>
<p>Math, like English, French, Spanish (西班牙語), or Arabic (阿拉伯語), is a second language that you must learn in order to be successful. There are verbs (動詞) and nouns (名詞)  in math, just like in any other language. In order to understand math, you must practice the language.</p>
<p>A verb is a “doing” word, such as running, jumping, or driving. In mathematics, verbs are also “doing” words. A math verb is called an operation (運算). Operations can be something you have used before, such as addition (加法), multiplication (乘法), subtraction (減法), or division (除法). They can also be much more complex like an exponent (指數) or square root (平方根). </p>
<p>A noun is usually described as a person, place, or thing. In mathematics, nouns are called numbers and variables (變數). A variable is a symbol, usually an English letter, written to replace an unknown or changing quantity.</p>
<p>An algebraic expression (代數表達式) is a mathematical phrase combining numbers and/or variables using mathematical operations. First we need to choose a variable for this unknown number. The letter n is a common choice, so we'll use that. To write the expression, first express 5 times the number by</p>
<p>5(n).</p>
<p>Now we need to express "2 more" than 5(n) Two more means that we should add two.</p>
<p>5(n)+2.</p>
<p>Exponent (指數): Exponents are used to describe the number of times that a term is multiplied by itself.</p>
<p>Operation (運算): Operations are actions performed on variables, constants, or expressions. Common operations are addition, subtraction, multiplication, and division.</p>
<p>Square root (平方根): The square root of a term is a value that must be multiplied by itself to equal the specified term. The square root of 9 is 3, since 3 * 3 = 9.</p>
<p>algebraic (代數的): The word algebraic indicates that a given expression or equation includes variables.</p>
<p>The order of operations (運算次序) specifies the order in which to perform each of multiple operations in an expression or equation. The order of operations is: P - parentheses, E - exponents, M/D - multiplication and division in order from left to right, A/S - addition and subtraction in order from left to right.</p>
<p>Some math verbs are “stronger” than others and must be done first. This method is known as the order of operations.</p>
<p>Whatever is found inside PARENTHESES must be done first. EXPONENTS are to be simplified next. MULTIPLICATION and DIVISION are equally important and must be performed moving left to right. ADDITION and SUBTRACTION are also equally important and must be performed moving left to right.</p>
<p>Parentheses (括號) "(" and ")" are used in algebraic expressions as grouping symbols.</p>
<p>Brackets [ ], are symbols that are used to group numbers in mathematics. Brackets are the 'second level' of grouping symbols, used to enclose items already in parentheses.</p>
<p>Grouping symbols are parentheses or brackets used to group numbers and operations.</p>
<p>A real number is a number that can be plotted on a number line. Real numbers include all rational and irrational numbers.</p>
<p>In algebra, to substitute (代換) means to replace a variable or term with a specific value.</p>
<p>A fraction is a part of a whole. A fraction is written mathematically as one value on top of another, separated by a fraction bar. It is also called a rational number.</p>
<p>A fraction bar is a line used to divide the numerator and the denominator of a fraction. The fraction bar means division.</p>
<p>Volume is the amount of space inside the bounds of a three-dimensional object.</p>
<p>expressions  表達式</p>
<p>equations 方程式: An equation is a mathematical sentence that describes two equal quantities. Equations contain equals signs.</p>
<p>functions 函式:  Functions are methods of explaining relationships and can be represented as a rule, a graph, a table, or in words.</p>
<p>The range of a function is the set of  values for which the function is defined.</p>
<p>The vertical axis is also referred to as the -axis of a coordinate graph. By convention, we graph the output variable on the -axis.</p>
<p>variable (變數): A variable is a symbol used to represent an unknown or changing quantity. The most common variables are a, b, x, y, m, and n.</p>
<p>Careers such as automobile accident investigators, quality control engineers, and insurance originators use equations to determine the value of variables.</p>
<p>The amount of money in a savings account, how many miles run in a year, or the number of trout in a pond are all described using functions.</p>
<p>choose the best variables to describe a situation, simplify an expression using the Order of Operations, describe functions in various ways, write equations, and solve problems using a systematic approach.</p>
<p>basic algebra concepts, such as properties of exponents, multiplying and factoring<br/>polynomials, equation solving, and applied problems.</p>
<p>graphs, slope, equations of lines, and functions, regression</p>
<p>The greater-than-or-equal-to symbol "$\ge$" indicates that the value on the left side of the symbol is greater than or equal to the value on the right.</p>
<p>The less-than-or-equal-to symbol "$\le$" indicates that the value on the left side of the symbol is lesser than or equal to the value on the right.</p>
<p>The not-equal-to symbol "$\ne$" indicates that the value on the left side of the symbol is not equal to the value on the right.</p>
<h1>STL</h1>
<p><a href="/downloads/STL.pdf">stl.pdf</a></p>
<p>Library to make reading, writing and modifying both binary and ascii STL files easy. </p>
<p><a href="https://pypi.org/project/numpy-stl/">https://pypi.org/project/numpy-stl/</a> </p>
<p>原始碼: <a href="https://github.com/WoLpH/numpy-stl">https://github.com/WoLpH/numpy-stl</a> </p>
<p>手冊: <a href="https://numpy-stl.readthedocs.io/en/latest/">https://numpy-stl.readthedocs.io/en/latest/</a> </p>
<p>作者網誌: <a href="https://w.wol.ph/">https://w.wol.ph/</a> </p>
<h4>範例</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from stl import mesh
from mpl_toolkits import mplot3d
from matplotlib import pyplot

# Create a new plot
figure = pyplot.figure()
axes = mplot3d.Axes3D(figure)

# Load the STL files and add the vectors to the plot
your_mesh = mesh.Mesh.from_file('tests/stl_binary/HalfDonut.stl')
axes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))

# Auto scale to the mesh size
scale = your_mesh.points.flatten(-1)
axes.auto_scale_xyz(scale, scale, scale)

# Show the plot to the screen
pyplot.show()</pre>
<p>列出 STL 零件檔案尺寸</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># Python script to find STL dimensions
# Requrements: sudo pip install numpy-stl

import math
import stl
from stl import mesh
import numpy

import os
import sys

if len(sys.argv) &lt; 2:
    sys.exit('Usage: %s [stl file]' % sys.argv[0])

if not os.path.exists(sys.argv[1]):
    sys.exit('ERROR: file %s was not found!' % sys.argv[1])

# this stolen from numpy-stl documentation
# https://pypi.python.org/pypi/numpy-stl

# find the max dimensions, so we can know the bounding box, getting the height,
# width, length (because these are the step size)...
def find_mins_maxs(obj):
    minx = maxx = miny = maxy = minz = maxz = None
    for p in obj.points:
        # p contains (x, y, z)
        if minx is None:
            minx = p[stl.Dimension.X]
            maxx = p[stl.Dimension.X]
            miny = p[stl.Dimension.Y]
            maxy = p[stl.Dimension.Y]
            minz = p[stl.Dimension.Z]
            maxz = p[stl.Dimension.Z]
        else:
            maxx = max(p[stl.Dimension.X], maxx)
            minx = min(p[stl.Dimension.X], minx)
            maxy = max(p[stl.Dimension.Y], maxy)
            miny = min(p[stl.Dimension.Y], miny)
            maxz = max(p[stl.Dimension.Z], maxz)
            minz = min(p[stl.Dimension.Z], minz)
    return minx, maxx, miny, maxy, minz, maxz

main_body = mesh.Mesh.from_file(sys.argv[1])

minx, maxx, miny, maxy, minz, maxz = find_mins_maxs(main_body)

# the logic is easy from there

print("File:", sys.argv[1])
print("X:", maxx - minx)
print("Y:", maxy - miny)
print("Z:", maxz - minz)</pre>
<h4>相關工具</h4>
<p>相關工具: <a href="https://github.com/WoLpH/python-utils">https://github.com/WoLpH/python-utils</a> </p>
<p>手冊: <a href="https://python-utils.readthedocs.io/en/latest/">https://python-utils.readthedocs.io/en/latest/</a> </p>
<h4>其他參考資料</h4>
<p><a href="https://github.com/apparentlymart/python-stl">https://github.com/apparentlymart/python-stl</a> </p>
<p>python-stl 內容</p>
<p>__init__.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import stl.ascii
import stl.binary

from stl.types import Solid, Facet, Vector3d


def read_ascii_file(file):
    """
    Read an STL file in the *ASCII* format.

    Takes a :py:class:`file`-like object (supporting a ``read`` method)
    and returns a :py:class:`stl.Solid` object representing the data
    from the file.

    If the file is invalid in any way, raises
    :py:class:`stl.ascii.SyntaxError`.
    """
    return stl.ascii.parse(file)


def read_binary_file(file):
    """
    Read an STL file in the *binary* format.

    Takes a :py:class:`file`-like object (supporting a ``read`` method)
    and returns a :py:class:`stl.Solid` object representing the data
    from the file.

    If the file is invalid in any way, raises
    :py:class:`stl.binary.FormatError`.
    """
    return stl.binary.parse(file)


def read_ascii_string(data):
    """
    Read geometry from a :py:class:`str` containing data in the STL *ASCII*
    format.

    This is just a wrapper around :py:func:`read_ascii_file` that first wraps
    the provided string in a :py:class:`StringIO.StringIO` object.
    """
    from StringIO import StringIO
    return parse_ascii_file(StringIO(data))


def read_binary_string(data):
    """
    Read geometry from a :py:class:`str` containing data in the STL *binary*
    format.

    This is just a wrapper around :py:func:`read_binary_file` that first wraps
    the provided string in a :py:class:`StringIO.StringIO` object.
    """
    from StringIO import StringIO
    return parse_binary_file(StringIO(data))</pre>
<p>ascii.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from stl.types import *


class KeywordToken(str):
    pass


class NumberToken(float):
    pass


def _token_type_name(token_type):
    NoneType = type(None)
    if token_type is NoneType:
        return 'end of file'
    elif token_type is KeywordToken:
        return 'keyword'
    elif token_type is NumberToken:
        return 'number'
    else:
        return 'unknown'


class Scanner(object):

    def __init__(self, file):
        self.file = file
        self.peeked = None
        self.peeked_byte = None
        self.peeked_col = 0
        self.peeked_row = 1

    def peek_byte(self):
        if self.peeked_byte is None:
            self.peeked_byte = self.file.read(1)
            if self.peeked_byte == '\n':
                self.peeked_row += 1
                self.peeked_col = 0
            else:
                self.peeked_col += 1

        return self.peeked_byte

    def get_byte(self):
        byte = self.peek_byte()
        self.peeked_byte = None
        return byte

    def peek_token(self):
        while self.peeked is None:
            b = self.peek_byte()
            self.token_start_row = self.peeked_row
            self.token_start_col = self.peeked_col

            if b == '':
                return None
            elif b.isalpha() or b == '_':
                self.peeked = self._read_keyword()
            elif b.isdigit() or b == '.' or b == '-':
                self.peeked = self._read_number()
            elif b.isspace():
                # Just skip over spaces
                self.get_byte()
                continue
            else:
                raise SyntaxError(
                    "Invalid character %r at line %i, column %i" % (
                        b, self.peeked_row, self.peeked_col
                    )
                )

        return self.peeked

    def get_token(self):
        token = self.peek_token()
        self.peeked = None
        return token

    def require_token(self, token_type, required_value=None):
        token = self.get_token()
        if isinstance(token, token_type):
            if required_value is None or token == required_value:
                return token
            else:
                got_token_type = _token_type_name(type(token))
                expected_token_type = _token_type_name(token_type)
                raise SyntaxError(
                    "Expected %s %r but got %s %r at line %i, column %i" % (
                        expected_token_type,
                        required_value,
                        got_token_type,
                        token,
                        self.token_start_row,
                        self.token_start_col,
                    )
                )
        else:
            got_token_type = _token_type_name(type(token))
            expected_token_type = _token_type_name(token_type)
            raise SyntaxError(
                "Expected %s but got %s at line %i, column %i" % (
                    expected_token_type,
                    got_token_type,
                    self.token_start_row,
                    self.token_start_col,
                )
            )

    def _read_keyword(self):
        ret_bytes = []
        start_row = self.peeked_row
        start_col = self.peeked_col
        while True:
            b = self.peek_byte()
            if b.isalpha() or b == '_' or b.isdigit():
                ret_bytes.append(self.get_byte())
            else:
                break

        ret = KeywordToken(''.join(ret_bytes))

        ret.start_row = start_row
        ret.start_col = start_col

        return ret

    def _read_number(self):
        ret_bytes = []
        start_row = self.peeked_row
        start_col = self.peeked_col
        while True:
            b = self.peek_byte()
            if b.isdigit() or b in ('.', '+', '-', 'e', 'E'):
                ret_bytes.append(self.get_byte())
            else:
                break

        try:
            ret = NumberToken(''.join(ret_bytes))
        except ValueError:
            raise SyntaxError(
                "Invalid float number at line %i, column %i" % (
                    start_row, start_col,
                )
            )

        ret.start_row = start_row
        ret.start_col = start_col

        return ret


class SyntaxError(ValueError):
    pass


def parse(file):
    scanner = Scanner(file)

    scanner.require_token(KeywordToken, "solid")
    name = str(scanner.require_token(KeywordToken))

    ret = Solid(name=name)

    def parse_facet():
        scanner.require_token(KeywordToken, "facet")
        scanner.require_token(KeywordToken, "normal")
        normal_x = scanner.require_token(NumberToken)
        normal_y = scanner.require_token(NumberToken)
        normal_z = scanner.require_token(NumberToken)
        normal = Vector3d(
            x=normal_x,
            y=normal_y,
            z=normal_z,
        )

        scanner.require_token(KeywordToken, "outer")
        scanner.require_token(KeywordToken, "loop")
        vertices = []
        for i in xrange(0, 3):
            scanner.require_token(KeywordToken, "vertex")
            vertex_x = scanner.require_token(NumberToken)
            vertex_y = scanner.require_token(NumberToken)
            vertex_z = scanner.require_token(NumberToken)
            vertices.append(
                Vector3d(
                    x=vertex_x,
                    y=vertex_y,
                    z=vertex_z,
                )
            )

        ret = Facet(
            normal=normal,
            vertices=vertices,
        )

        scanner.require_token(KeywordToken, "endloop")
        scanner.require_token(KeywordToken, "endfacet")

        return ret

    while True:
        token = scanner.peek_token()
        token_type = type(token)

        if token_type is KeywordToken and token == 'endsolid':
            break
        elif token_type is KeywordToken and token == 'facet':
            facet = parse_facet()
            ret.facets.append(facet)
        else:
            got_token_type = _token_type_name(token_type)
            expected_token_type = _token_type_name(token_type)
            raise SyntaxError(
                "Unexpected %s %r at line %i, column %i" % (
                    got_token_type,
                    token,
                    token.start_row,
                    token.start_col,
                )
            )

    scanner.require_token(KeywordToken, "endsolid")
    end_name = str(scanner.require_token(KeywordToken))
    if name != end_name:
        raise SyntaxError(
            "Solid started named %r but ended named %r" % (
                name, end_name,
            )
        )

    return ret


def write(solid, file):
    name = solid.name
    if name is None:
        name = "unnamed"

    file.write(("solid %s\n" % name).encode())
    for facet in solid.facets:
        file.write(("  facet normal %g %g %g\n" % facet.normal).encode())
        file.write(b"    outer loop\n")
        for vertex in facet.vertices:
            file.write(("      vertex %g %g %g\n" % vertex).encode())
        file.write(b"    endloop\n")
        file.write(b"  endfacet\n")
    file.write(("endsolid %s\n" % name).encode())</pre>
<p>binary.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import struct
from stl.types import *


class Reader(object):

    def __init__(self, file):
        self.file = file
        self.offset = 0

    def read_bytes(self, byte_count):
        bytes = self.file.read(byte_count)
        if len(bytes) &lt; byte_count:
            raise FormatError(
                "Unexpected end of file at offset %i" % (
                    self.offset + len(bytes),
                )
            )
        self.offset += byte_count
        return bytes

    def read_uint32(self):
        bytes = self.read_bytes(4)
        return struct.unpack('&lt;I', bytes)[0]

    def read_uint16(self):
        bytes = self.read_bytes(2)
        return struct.unpack('&lt;H', bytes)[0]

    def read_float(self):
        bytes = self.read_bytes(4)
        return struct.unpack('&lt;f', bytes)[0]

    def read_vector3d(self):
        x = self.read_float()
        y = self.read_float()
        z = self.read_float()
        return Vector3d(x, y, z)

    def read_header(self):
        bytes = self.read_bytes(80)
        return struct.unpack('80s', bytes)[0].strip('\0')


class FormatError(ValueError):
    pass


def parse(file):
    r = Reader(file)

    name = r.read_header()[6:]

    ret = Solid(name=name)

    num_facets = r.read_uint32()

    for i in xrange(0, num_facets):
        normal = r.read_vector3d()
        vertices = tuple(
            r.read_vector3d() for j in xrange(0, 3)
        )

        attr_byte_count = r.read_uint16()
        if attr_byte_count &gt; 0:
            # The attribute bytes are not standardized, but some software
            # encodes additional information here. We return the raw bytes
            # to allow the caller to potentially do something with them if
            # the format for a particular file is known.
            attr_bytes = r.read_bytes(attr_byte_count)
        else:
            attr_bytes = None

        ret.add_facet(
            normal=normal,
            vertices=vertices,
            attributes=attr_bytes,
        )

    return ret


def write(solid, file):
    # Empty header
    file.write(b'\0' * 80)

    # Number of facets
    file.write(struct.pack('&lt;I', len(solid.facets)))

    for facet in solid.facets:
        file.write(struct.pack('&lt;3f', *facet.normal))
        for vertex in facet.vertices:
            file.write(struct.pack('&lt;3f', *vertex))
        file.write(b'\0\0')  # no attribute bytes</pre>
<p>types.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import math


class Solid(object):
    """
    A solid object; the root element of an STL file.
    """

    #: The name given to the object by the STL file header.
    name = None

    #: :py:class:`list` of :py:class:`stl.Facet` objects representing the
    #: facets (triangles) that make up the exterior surface of this object.
    facets = []

    def __init__(self, name=None, facets=None):
        self.name = name
        self.facets = facets if facets is not None else []

    def add_facet(self, *args, **kwargs):
        """
        Append a new facet to the object. Takes the same arguments as the
        :py:class:`stl.Facet` type.
        """
        self.facets.append(Facet(*args, **kwargs))

    @property
    def surface_area(self):
        """
        The sum of the areas of all facets in the object.
        """
        return reduce(
            lambda accum, facet: accum + facet.area,
            self.facets,
            0.0,
        )

    def write_binary(self, file):
        """
        Write this object to a file in STL *binary* format.

        ``file`` must be a file-like object (supporting a ``write`` method),
        to which the data will be written.
        """
        from stl.binary import write
        write(self, file)

    def write_ascii(self, file):
        """
        Write this object to a file in STL *ascii* format.

        ``file`` must be a file-like object (supporting a ``write`` method),
        to which the data will be written.
        """
        from stl.ascii import write
        write(self, file)

    def __eq__(self, other):
        if type(other) is Solid:
            if self.name != other.name:
                return False
            if len(self.facets) != len(other.facets):
                return False
            for i, self_facet in enumerate(self.facets):
                if self_facet != other.facets[i]:
                    return False
            return True
        else:
            return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return '&lt;stl.types.Solid name=%r, facets=%r&gt;' % (
            self.name,
            self.facets,
        )


class Facet(object):
    """
    A facet (triangle) from a :py:class:`stl.Solid`.
    """

    #: Raw binary attribute bytes. According to the STL spec these are unused
    #: and thus this should always be empty, but some modeling software
    #: encodes non-standard data in here which callers may wish to access.
    #:
    #: At present these attribute bytes are populated only when reading binary
    #: STL files (since ASCII STL files have no place for this data) *and*
    #: they are ignored when *writing* a binary STL file, so round-tripping
    #: a file through this library will lose the non-standard attribute data.
    attributes = None

    #: The 'normal' vector of the facet, as a :py:class:`stl.Vector3d`.
    normal = None

    #: 3-element sequence of :py:class:`stl.Vector3d` representing the
    #: facet's three vertices, in order.
    vertices = None

    def __init__(self, normal, vertices, attributes=None):
        self.normal = Vector3d(*normal)
        self.vertices = tuple(
            Vector3d(*x) for x in vertices
        )

        if len(self.vertices) != 3:
            raise ValueError('Must pass exactly three vertices')

    def __eq__(self, other):
        if type(other) is Facet:
            return (
                self.normal == other.normal and
                self.vertices == other.vertices
            )
        else:
            return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __repr__(self):
        return '&lt;stl.types.Facet normal=%r, vertices=%r, area=%r&gt;' % (
            self.normal,
            self.vertices,
            self.area,
        )

    @property
    def a(self):
        """
        The length the side of the facet between vertices[0] and vertices[1]
        """
        return abs(
            math.sqrt(
                pow((self.vertices[0].x - self.vertices[1].x), 2) +
                pow((self.vertices[0].y - self.vertices[1].y), 2) +
                pow((self.vertices[0].z - self.vertices[1].z), 2)
            )
        )

    @property
    def b(self):
        """
        The length of the side of the facet between vertices[0] and vertices[2]
        """
        return abs(
            math.sqrt(
                pow((self.vertices[0].x - self.vertices[2].x), 2) +
                pow((self.vertices[0].y - self.vertices[2].y), 2) +
                pow((self.vertices[0].z - self.vertices[2].z), 2)
            )
        )

    @property
    def c(self):
        """
        The length of the side of the facet between vertices[1] and vertices[2]
        """
        return abs(
            math.sqrt(
                pow((self.vertices[1].x - self.vertices[2].x), 2) +
                pow((self.vertices[1].y - self.vertices[2].y), 2) +
                pow((self.vertices[1].z - self.vertices[2].z), 2)
            )
        )

    @property
    def perimeter(self):
        """
        The length of the perimeter of the facet.
        """
        return self.a + self.b + self.c

    @property
    def area(self):
        """
        The surface area of the facet, as computed by Heron's Formula.
        """
        p = self.perimeter / 2.0
        return abs(math.sqrt(p * (p - self.a) * (p - self.b) * (p - self.c)))


class Vector3d(tuple):
    """
    Three-dimensional vector.

    Used to represent both normals and vertices of :py:class:`stl.Facet`
    objects.

    This is a subtype of :py:class:`tuple`, so can also be treated like a
    three-element tuple in (``x``, ``y``, ``z``) order.
    """

    def __new__(cls, x, y, z):
        return tuple.__new__(cls, (x, y, z))

    def __init__(self, x, y, z):
        pass

    @property
    def x(self):
        """
        The X value of the vector, which most applications interpret
        as the left-right axis.
        """
        return self[0]

    @x.setter
    def x(self, value):
        self[0] = value

    @property
    def y(self):
        """
        The Y value of the vector, which most applications interpret
        as the in-out axis.
        """
        return self[1]

    @y.setter
    def y(self, value):
        self[1] = value

    @property
    def z(self):
        """
        The Z value of the vector, which most applications interpret
        as the up-down axis.
        """
        return self[2]

    @z.setter
    def z(self, value):
        self[2] = value</pre>
<p>test_types.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import unittest
from stl.types import *


class TestTypes(unittest.TestCase):

    def test_facet_geometry(self):
        facet = Facet(
            (1, 0, 0),
            [
                (0, 0, 0),
                (1, 0, 0),
                (0, 1, 0),
            ],
        )
        self.assertEqual(facet.a, 1.0)
        self.assertEqual(facet.b, 1.0)
        self.assertAlmostEqual(facet.c, 1.4142135623730951)

        self.assertAlmostEqual(
            facet.perimeter,
            1.0 + 1.0 + 1.4142135623730951,
        )

        self.assertAlmostEqual(facet.area, 0.5)

    def test_solid_geometry(self):
        solid = Solid(
            "test",
            [
                Facet(
                    (1, 0, 0),
                    [
                        (0, 0, 0),
                        (1, 0, 0),
                        (0, 1, 0),
                    ],
                ),
                Facet(
                    (1, 0, 0),
                    [
                        (0, 0, 0),
                        (1, 0, 0),
                        (0, 0, 1),
                    ],
                ),
            ],
        )

        self.assertAlmostEqual(solid.surface_area, 0.5 + 0.5)</pre>
<p>test_code_style.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import unittest
import pep8
import os.path


tests_dir = os.path.dirname(__file__)
modules_dir = os.path.abspath(os.path.join(tests_dir, "..", "stl"))


class TestCodeStyle(unittest.TestCase):

    def test_pep8_conformance(self):
        pep8style = pep8.StyleGuide()
        result = pep8style.check_files([tests_dir, modules_dir])
        self.assertEqual(
            result.total_errors,
            0,
            "Found pep8 conformance issues",
        )</pre>
<p>test_ascii.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from StringIO import StringIO
import unittest
from stl.ascii import *


class TestScanner(unittest.TestCase):

    def _scanner_for_str(self, string):
        return Scanner(StringIO(string))

    def _get_tokens(self, string):
        scanner = self._scanner_for_str(string)
        tokens = []

        while True:
            token = scanner.get_token()
            if token is not None:
                tokens.append(token)
            else:
                break

        return tokens

    def test_numbers(self):
        tokens = self._get_tokens("1 0.1 -0.1 1e2\n1.2e2 1.2e-2 1.2e+2 1.2E+2")
        self.assertEqual(
            tokens,
            [
                1, 0.1, -0.1, 100, 120, 0.012, 120.0, 120.0,
            ],
        )

        self.assertEqual(
            [tokens[1].start_row, tokens[1].start_col],
            [1, 3],
        )
        self.assertEqual(
            [tokens[5].start_row, tokens[5].start_col],
            [2, 7],
        )

        with self.assertRaises(SyntaxError):
            self._get_tokens("1e1e1")

        with self.assertRaises(SyntaxError):
            self._get_tokens("1.1.1")

        with self.assertRaises(SyntaxError):
            self._get_tokens("--2")

    def test_keywords(self):
        tokens = self._get_tokens("hello world a\nb c _d e_f g2")
        self.assertEqual(
            tokens,
            [
                'hello', 'world', 'a', 'b', 'c', '_d', 'e_f', 'g2',
            ],
        )

        self.assertEqual(
            [tokens[1].start_row, tokens[1].start_col],
            [1, 7],
        )
        self.assertEqual(
            [tokens[4].start_row, tokens[4].start_col],
            [2, 3],
        )

    def test_spaces(self):
        tokens = self._get_tokens(" \n\t")
        self.assertEqual(
            tokens,
            [],
        )

    def test_require_token(self):
        scanner = self._scanner_for_str("baz")
        try:
            scanner.require_token(KeywordToken)
        except SyntaxError:
            self.fail('Unexpected SyntaxError')

        scanner = self._scanner_for_str("baz")
        try:
            scanner.require_token(KeywordToken, "baz")
        except SyntaxError:
            self.fail('Unexpected SyntaxError')

        scanner = self._scanner_for_str("baz")
        with self.assertRaises(SyntaxError):
            scanner.require_token(NumberToken)

        scanner = self._scanner_for_str("baz")
        with self.assertRaises(SyntaxError):
            scanner.require_token(KeywordToken, "foo")


class TestParser(unittest.TestCase):

    def _parse_str(self, string):
        return parse(StringIO(string))

    def test_empty(self):
        with self.assertRaises(SyntaxError):
            self._parse_str('')

    def test_no_facets(self):
        self.assertEqual(
            self._parse_str("solid Baz\nendsolid Baz\n"),
            Solid(name="Baz"),
        )

    def test_inconsistent_name(self):
        with self.assertRaises(SyntaxError):
            self._parse_str("solid Baz\nendsolid Bonk\n")

    def test_facets(self):
        self.assertEqual(
            self._parse_str(
                "solid Baz\n"
                "  facet normal 1 2 3\n"
                "    outer loop\n"
                "      vertex 4 5 6\n"
                "      vertex 7 8 9\n"
                "      vertex 10 11 12\n"
                "    endloop\n"
                "  endfacet\n"
                "  facet normal 1.1 2.1 3.1\n"
                "    outer loop\n"
                "      vertex 4.1 5.1 6.1\n"
                "      vertex 7.1 8.1 9.1\n"
                "      vertex 10.1 11.1 12.1\n"
                "    endloop\n"
                "  endfacet\n"
                "endsolid Baz\n"
            ),
            Solid(
                name="Baz",
                facets=[
                    Facet(
                        normal=Vector3d(1.0, 2.0, 3.0),
                        vertices=(
                            Vector3d(4.0, 5.0, 6.0),
                            Vector3d(7.0, 8.0, 9.0),
                            Vector3d(10.0, 11.0, 12.0),
                        ),
                    ),
                    Facet(
                        normal=Vector3d(1.1, 2.1, 3.1),
                        vertices=(
                            Vector3d(4.1, 5.1, 6.1),
                            Vector3d(7.1, 8.1, 9.1),
                            Vector3d(10.1, 11.1, 12.1),
                        ),
                    ),
                ],
            ),
        )


class TestWriter(unittest.TestCase):

    def assertResultEqual(self, solid, expected):
        f = StringIO('')
        solid.write_ascii(f)
        self.assertEqual(
            f.getvalue(),
            expected,
        )

    def test_empty(self):
        self.assertResultEqual(
            Solid(),
            'solid unnamed\n'
            'endsolid unnamed\n'
        )

    def test_with_facets(self):
        self.assertResultEqual(
            Solid(
                name='withfacets',
                facets=[
                    Facet(
                        normal=(1, 2, 3),
                        vertices=[
                            (4, 5, 6),
                            (7, 8, 9),
                            (10, 11, 12),
                        ],
                    ),
                    Facet(
                        normal=(1.1, 2.1, 3.1),
                        vertices=[
                            (4.1, 5.1, 6.1),
                            (7.1, 8.1, 9.1),
                            (10.1, 11.1, 12.1),
                        ],
                    ),
                ],
            ),
            'solid withfacets\n'
            '  facet normal 1 2 3\n'
            '    outer loop\n'
            '      vertex 4 5 6\n'
            '      vertex 7 8 9\n'
            '      vertex 10 11 12\n'
            '    endloop\n'
            '  endfacet\n'
            '  facet normal 1.1 2.1 3.1\n'
            '    outer loop\n'
            '      vertex 4.1 5.1 6.1\n'
            '      vertex 7.1 8.1 9.1\n'
            '      vertex 10.1 11.1 12.1\n'
            '    endloop\n'
            '  endfacet\n'
            'endsolid withfacets\n'
        )</pre>
<p>test_binary.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from StringIO import StringIO
import unittest
from stl.binary import *

EMPTY_HEADER = '\0' * 80
T_HDR = '\x73\x6f\x6c\x69\x64\x20\x54\x65\x73\x74\x66\x69\x6c\x65' + ('\0'*66)


class TestParser(unittest.TestCase):

    def _parse_str(self, string):
        return parse(StringIO(string))

    def test_empty(self):
        with self.assertRaises(FormatError):
            self._parse_str('')

    def test_no_facets(self):
        solid = self._parse_str(
            T_HDR + '\0\0\0\0'
        )
        self.assertEqual(
            solid,
            Solid(
                name='Testfile',
                facets=[],
            ),
        )

    def test_missing_facets(self):
        with self.assertRaises(FormatError):
            # Declared that we have two facets but we
            # actually have none.
            self._parse_str(
                T_HDR + '\x02\x00\x00\x00'
            )

    def test_valid(self):
        solid = self._parse_str(
            T_HDR +
            '\x02\x00\x00\x00'  # two facets
            # first facet
            '\x00\x00\x80\x3f'  # normal x = 1.0
            '\x00\x00\x00\x40'  # normal y = 2.0
            '\x00\x00\x40\x40'  # normal z = 3.0
            '\x00\x00\x80\x40'  # vertex x = 4.0
            '\x00\x00\xa0\x40'  # vertex y = 5.0
            '\x00\x00\xc0\x40'  # vertex z = 6.0
            '\x00\x00\xe0\x40'  # vertex x = 7.0
            '\x00\x00\x00\x41'  # vertex y = 8.0
            '\x00\x00\x10\x41'  # vertex z = 9.0
            '\x00\x00\x20\x41'  # vertex x = 10.0
            '\x00\x00\x30\x41'  # vertex y = 11.0
            '\x00\x00\x40\x41'  # vertex z = 12.0
            '\x04\x00'          # four attribute bytes
            '\x00\x00\x80\x7f'  # dummy attribute bytes (float Infinity)
            # second facet
            '\x00\x00\x80\x3f'  # normal x = 1.0
            '\x00\x00\x80\x3f'  # normal y = 1.0
            '\x00\x00\x80\x3f'  # normal z = 1.0
            '\x00\x00\x80\x3f'  # vertex x = 1.0
            '\x00\x00\x80\x3f'  # vertex y = 1.0
            '\x00\x00\x80\x3f'  # vertex z = 1.0
            '\x00\x00\x80\x3f'  # vertex x = 1.0
            '\x00\x00\x80\x3f'  # vertex y = 1.0
            '\x00\x00\x80\x3f'  # vertex z = 1.0
            '\x00\x00\x80\x3f'  # vertex x = 1.0
            '\x00\x00\x80\x3f'  # vertex y = 1.0
            '\x00\x00\x80\x3f'  # vertex z = 1.0
            '\x00\x00'          # no attribute bytes
        )
        self.assertEqual(
            solid,
            Solid(
                name='Testfile',
                facets=[
                    Facet(
                        normal=Vector3d(1.0, 2.0, 3.0),
                        vertices=(
                            Vector3d(4.0, 5.0, 6.0),
                            Vector3d(7.0, 8.0, 9.0),
                            Vector3d(10.0, 11.0, 12.0),
                        ),
                        attributes='\x00\x00\x80\x7f',
                    ),
                    Facet(
                        normal=Vector3d(1.0, 1.0, 1.0),
                        vertices=(
                            Vector3d(1.0, 1.0, 1.0),
                            Vector3d(1.0, 1.0, 1.0),
                            Vector3d(1.0, 1.0, 1.0),
                        ),
                        attributes=None,
                    ),
                ],
            ),
        )


class TestWriter(unittest.TestCase):

    def assertResultEqual(self, solid, expected):
        f = StringIO('')
        solid.write_binary(f)
        self.assertEqual(
            f.getvalue(),
            expected,
        )

    def test_empty(self):
        self.assertResultEqual(
            Solid(),
            EMPTY_HEADER +
            '\0\0\0\0'
        )

    def test_with_facets(self):
        self.assertResultEqual(
            Solid(
                name=None,
                facets=[
                    Facet(
                        normal=Vector3d(1.0, 2.0, 3.0),
                        vertices=(
                            Vector3d(4.0, 5.0, 6.0),
                            Vector3d(7.0, 8.0, 9.0),
                            Vector3d(10.0, 11.0, 12.0),
                        ),
                        attributes=None,
                    ),
                    Facet(
                        normal=Vector3d(1.0, 1.0, 1.0),
                        vertices=(
                            Vector3d(1.0, 1.0, 1.0),
                            Vector3d(1.0, 1.0, 1.0),
                            Vector3d(1.0, 1.0, 1.0),
                        ),
                        attributes=None,
                    ),
                ],
            ),
            EMPTY_HEADER +
            '\x02\x00\x00\x00'  # two facets
            # first facet
            '\x00\x00\x80\x3f'  # normal x = 1.0
            '\x00\x00\x00\x40'  # normal y = 2.0
            '\x00\x00\x40\x40'  # normal z = 3.0
            '\x00\x00\x80\x40'  # vertex x = 4.0
            '\x00\x00\xa0\x40'  # vertex y = 5.0
            '\x00\x00\xc0\x40'  # vertex z = 6.0
            '\x00\x00\xe0\x40'  # vertex x = 7.0
            '\x00\x00\x00\x41'  # vertex y = 8.0
            '\x00\x00\x10\x41'  # vertex z = 9.0
            '\x00\x00\x20\x41'  # vertex x = 10.0
            '\x00\x00\x30\x41'  # vertex y = 11.0
            '\x00\x00\x40\x41'  # vertex z = 12.0
            '\x00\x00'          # no attribute bytes
            # second facet
            '\x00\x00\x80\x3f'  # normal x = 1.0
            '\x00\x00\x80\x3f'  # normal y = 1.0
            '\x00\x00\x80\x3f'  # normal z = 1.0
            '\x00\x00\x80\x3f'  # vertex x = 1.0
            '\x00\x00\x80\x3f'  # vertex y = 1.0
            '\x00\x00\x80\x3f'  # vertex z = 1.0
            '\x00\x00\x80\x3f'  # vertex x = 1.0
            '\x00\x00\x80\x3f'  # vertex y = 1.0
            '\x00\x00\x80\x3f'  # vertex z = 1.0
            '\x00\x00\x80\x3f'  # vertex x = 1.0
            '\x00\x00\x80\x3f'  # vertex y = 1.0
            '\x00\x00\x80\x3f'  # vertex z = 1.0
            '\x00\x00'          # no attribute bytes
        )</pre>
<p></p>
<h1>CNC</h1>
<p><a href="https://github.com/tmpvar/gcode-simulator">https://github.com/tmpvar/gcode-simulator</a> </p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">&lt;svg width="400" height="110"&gt;
  &lt;rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" /&gt;
  Sorry, your browser does not support inline SVG.  
&lt;/svg&gt;</pre>
<p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/93/three.min.js" type="text/javascript"></script>
<script src="/static/cnc/gcode-simulator.js" type="text/javascript"></script>
<script src="/static/cnc/machine.js" type="text/javascript"></script>
<script src="/static/cnc/stats.js" type="text/javascript"></script>
<script src="/static/cnc/vec2.js" type="text/javascript"></script>
<script src="/static/cnc/SVGReader.js" type="text/javascript"></script>
<script src="/static/cnc/svg2gcode.js" type="text/javascript"></script>
<script src="/static/cnc/jquery.js" type="text/javascript"></script>
</p>
<!-- hide starts -->
<section class="row" style="display: none;">
<section class="span4">
<h4 class="left10px">workarea extents</h4>
<p><label class="span1">X</label> <input class="span1" name="xmin" type="text" value="0"/> <input class="span1" name="xmax" type="text" value="600"/></p>
<p><label class="span1">Y</label> <input class="span1" name="ymin" type="text" value="0"/> <input class="span1" name="ymax" type="text" value="600"/></p>
<p><label class="span1">Z</label> <input class="span1" name="zmin" type="text" value="0"/> <input class="span1" name="zmax" type="text" value="150"/></p>
</section>
<section class="span4">
<h4 class="left10px">tooling</h4>
<p><label class="span2">Safe Z</label><input class="span1" name="safeZ" type="text" value="142"/></p>
<p><label class="span2">Cut Z</label><input class="span1" name="cutZ" type="text" value="144"/></p>
<p><label class="span2">Material Width</label><input class="span1" name="materialWidth" type="text" value="5.04"/></p>
<p><label class="span2">Feed Rate</label> <input class="span1" name="feedRate" type="text" value="900"/></p>
<p><label class="span2">Seek Rate</label> <input class="span1" name="seekRate" type="text" value="900"/></p>
</section>
<section class=" span4">
<h4 class="left10px">simulation speed</h4>
<p><label class="span2">Percent</label><input class="span1" name="z-safe" type="text" value="100"/></p>
</section>
</section>
<!-- hide ends -->
<h4>SVG</h4>
<section class="row">
<section class="span6">
<section class="span5 pane left10px top10px"><textarea class="span5" id="svg" rows="11"></textarea></section>
<section class="span5 pane left10px top10px" id="editor"></section>
<section class="span6 pane" id="3d"></section>
</section>
</section>
<h4>gcode</h4>
<section class="row">
<section class="span6"><textarea class="span5" id="gcode" rows="11"></textarea></section>
</section>
<p>
<script>
    $(function() {
      console.log('ready');
      // setup the gcode input
      var gcodeElement =document.getElementById('gcode');
      var gcodes = gcodeElement.value;
      machine.fromString(gcodes);
      machine.begin(function() { console.log('done'); });

      var changing = false;
      gcodeElement.addEventListener('keyup', function() {
        if (gcodes !== gcodeElement.value) {
          clearTimeout(changing);
          changing = setTimeout(function() {
            gcodes = gcodeElement.value;
            machine.cancel();
            machine.fromString(gcodes);
            machine.begin(function() {
              console.log('done');
            });
          }, 1000);
        }
      });



      $('#svg').on('keyup', function() {
        console.log('here')
        $('#gcode').val(svg2gcode(document.getElementById('svg').value, {
          scale : 1,
          cutZ : 108,
          safeZ: 80
        }));

        machine.cancel();
        machine.fromString($('#gcode').val());
        machine.begin(function() { console.log('done'); });
      });
    });
  </script>
<script src="/static/cnc/renderer.js" type="text/javascript"></script>
</p><h1>Javascript</h1>
<p>學習: <a href="https://javascript.info/">https://javascript.info/</a> </p>
<p><a href="https://www.learn-js.org/">https://www.learn-js.org/</a> </p>
<p>寫在網頁的 Javascript 可以:</p>
<ol>
<li>新增 html 內容, 改變既有 html 內容, 或者更改頁面格式</li>
<li>與使用者透過鍵盤或滑鼠互動</li>
<li>從客戶端向伺服器傳送資料, 或取得資料</li>
<li>從客戶端存取 cookies</li>
<li>將資料存入客戶端的 local storage 中</li>
</ol><h2>Brython</h2>
<h4>Documentation</h4>
<p><a href="https://brython.info/static_doc/en/intro.html?lang=en">https://brython.info/static_doc/en/intro.html?lang=en</a> </p>
<h4>有關 Javascript 中的 this 導入</h4>
<p><a href="https://www.brython.info/static_doc/en/javascript.html">https://www.brython.info/static_doc/en/javascript.html</a> </p>
<h4>Demo</h4>
<p><a href="https://www.brython.info/demo.html?lang=en">https://www.brython.info/demo.html?lang=en#</a> </p>
<h4>Gallery</h4>
<p><a href="https://brython.info/gallery/gallery_en.html">https://brython.info/gallery/gallery_en.html</a> </p>
<h4>vue.py</h4>
<p><a href="https://github.com/stefanhoelzl/vue.py">https://github.com/stefanhoelzl/vue.py</a> </p>
<h4>brySVG</h4>
<p><a href="https://github.com/andy31lewis/brySVG">https://github.com/andy31lewis/brySVG</a> </p>
<h4>More Examples</h4>
<p><a href="https://github.com/brython-dev/brython/wiki/Brython-in-the-wild">https://github.com/brython-dev/brython/wiki/Brython-in-the-wild</a> </p>
<h4>繪圖範例</h4>
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<div id="brython_div"></div>
<p>
<script>
window.onload=function(){
brython(1);
}
</script>
<script type="text/python3">
# 導入 doc
from browser import document as doc
from browser import html
import math
canvas = html.CANVAS(width = 300, height = 200)
canvas.style = {"width": "100%"}
canvas.id = "taiwan_flag"
brython_div = doc["brython_div"]
brython_div <= canvas

# 準備繪圖畫布
canvas = doc["taiwan_flag"]
ctx = canvas.getContext("2d")
# 進行座標轉換, x 軸不變, y 軸反向且移動 canvas.height 單位光點
# ctx.setTransform(1, 0, 0, -1, 0, canvas.height)
# 以下採用 canvas 原始座標繪圖
flag_w = canvas.width
flag_h = canvas.height
circle_x = flag_w/4
circle_y = flag_h/4
# 先畫滿地紅
ctx.fillStyle='rgb(255, 0, 0)'
ctx.fillRect(0,0,flag_w,flag_h)
# 再畫青天
ctx.fillStyle='rgb(0, 0, 150)'
ctx.fillRect(0,0,flag_w/2,flag_h/2)
# 畫十二道光芒白日
ctx.beginPath()
star_radius = flag_w/8
angle = 0
for i in range(24):
    angle += 5*math.pi*2/12
    toX = circle_x + math.cos(angle)*star_radius
    toY = circle_y + math.sin(angle)*star_radius
    # 只有 i 為 0 時移動到 toX, toY, 其餘都進行 lineTo
    if (i):
        ctx.lineTo(toX, toY)
    else:
        ctx.moveTo(toX, toY)
ctx.closePath()
# 將填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
# 白日:藍圈
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w*17/240, 0, math.pi*2, True)
ctx.closePath()
# 填色設為藍色
ctx.fillStyle = 'rgb(0, 0, 149)'
ctx.fill()
# 白日:白心
ctx.beginPath()
ctx.arc(circle_x, circle_y, flag_w/16, 0, math.pi*2, True)
ctx.closePath()
# 填色設為白色
ctx.fillStyle = '#fff'
ctx.fill()
</script>
</p>
<h4>Geometric Constraint Solver</h4>
<p><a href="https://www.mattkeeter.com/projects/constraints/">https://www.mattkeeter.com/projects/constraints/</a> </p>
<h4>Ajax 範例</h4>
<p>伺服器端使用 Flask</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, render_template, request, jsonify

# Initialize the Flask application
app = Flask(__name__)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/add_numbers', methods=['POST'])
def add_numbers():
    a = request.form.get('a', 0, type=int)
    b = request.form.get('b', 0, type=int)
    #return jsonify(result = a+b)
    # 必須傳回字串?
    return str(a+b)

if __name__ == '__main__':
    app.run(debug=True)

</pre>
<p>客戶端使用 Brython</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"&gt;&lt;/script&gt;
    &lt;link href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css" rel="stylesheet"&gt;
    &lt;script src="http://brython.info/src/brython_dist.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload="brython()"&gt;
  &lt;script type="text/python"&gt;
    from browser import document
    from browser import ajax
    # https://www.brython.info/static_doc/en/ajax.html
    
    def on_complete(req):
        document["txt_area"] .clear()
        if req.status==200 or req.status==0:
            document["txt_area"] &lt;= req.text
        else:
            document["txt_area"] &lt;= "error "+req.text
            
    def get(url):  
        # req 從 ajax 模組中的 ajax 類別建立案例, 為一個 ajax 物件        
        req = ajax.ajax()
        # a 為 id="A" 輸入欄位中所輸入的值
        a = document['A'].value
        # b 為 id="B" 輸入欄位中所輸入的值        
        b = document['B'].value
        # ajax 物件中的 bind 方法, 第一個輸入變數為 evt, 'complete' 表示 ajax 從伺服器取值完成後, 執行 on_complete 函式
        req.bind('complete', on_complete)
        req.open('POST', url, True)
        req.set_header('content-type','application/x-www-form-urlencoded')
        req.send({"a": a, "b":b}) 
    
    # 使用者按下 id="calculate" 按鈕, 將會執行上述 get("/add_numbers") 函式
    document['calculate'].bind('click',lambda ev:get('/add_numbers'))

&lt;/script&gt;
  
    &lt;div class="container"&gt;
      &lt;div class="header"&gt;
        &lt;h3 class="text-muted"&gt;Brython ajax example&lt;/h3&gt;
      &lt;/div&gt;
      &lt;div&gt;
    &lt;input type="text" id="A" size="5" name="a"&gt; +
    &lt;input type="text" id ="B" size="5" name="b"&gt; =
    &lt;div id="txt_area"&gt;&lt;/div&gt;
    &lt;p&gt;&lt;button id="calculate"&gt;calculate server side&lt;/button&gt;
      &lt;/form&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
<h4>參考資料:</h4>
<p><a href="https://stackoverflow.com/questions/41957490/send-canvas-image-data-uint8clampedarray-to-flask-server-via-ajax">https://stackoverflow.com/questions/41957490/send-canvas-image-data-uint8clampedarray-to-flask-server-via-ajax</a> </p>
<h4>Konva js</h4>
<p><a href="https://code.tutsplus.com/series/manipulating-html5-canvas-using-konva--cms-1242">https://code.tutsplus.com/series/manipulating-html5-canvas-using-konva--cms-1242</a> </p>
<h3>Ggame</h3>
<p>為能在 canvas 模式下正確執行, 必須採用下列 sysdeps.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def module_exists(module_name):
    try:
        __import__(module_name)
    except ImportError:
        return False
    else:
        return True

if module_exists('browser') and module_exists('javascript'):

    from browser import window, document, load
    from javascript import JSObject, JSConstructor

    # pixi 與 buzz 模組, 改為在頁面載入時導入    
  
    major = window.__BRYTHON__.implementation[0]
    minor = window.__BRYTHON__.implementation[1]
    # brython 新版與 Javascript 程式庫結合運用方法
    if major == 3 and minor &gt;= 3 or major &gt; 3:
        GFX = window.PIXI
        GFX_Rectangle = GFX.Rectangle.new
        GFX_Texture = GFX.Texture.new
        GFX_Texture_fromImage = GFX.Texture.fromImage.new
        GFX_Sprite = GFX.Sprite.new
        GFX_Graphics = GFX.Graphics.new()
        GFX_Text = GFX.Text.new
        GFX_NewStage = GFX.Container.new
        SND = window.buzz
        SND_Sound = SND.sound.new
    else:
        # 舊版 Brython 呼叫 Javascript 物件方法
        GFX = JSObject(window.PIXI)
        GFX_Rectangle = JSConstructor(GFX.Rectangle)
        GFX_Texture = JSConstructor(GFX.Texture)
        GFX_Texture_fromImage = JSConstructor(GFX.Texture.fromImage)
        GFX_Sprite = JSConstructor(GFX.Sprite)
        GFX_Graphics = JSConstructor(GFX.Graphics)()
        GFX_Text = JSConstructor(GFX.Text)
        GFX_NewStage = JSConstructor(GFX.Container)
        SND = JSObject(window.buzz)
        SND_Sound = JSConstructor(SND.sound)
    GFX_DetectRenderer = GFX.autoDetectRenderer 
  
    class GFX_Window(object):
        
        def __init__(self, width, height, onclose):
            canvas = window.document.getElementById('ggame-canvas')
            if canvas:
                '''
                # 原始 Ggame 使用方法, 無法使用, 改為下列方式運用.
                self._w = window
                window.bsUI.graphicsmode()
                options = {'transparent':True, 'antialias':True, 'view':canvas}
                attachpoint = window.document.getElementById('graphics-column')
                w, h = attachpoint.clientWidth, attachpoint.clientHeight
                '''
                self._w =window
                w, h = self._w.innerWidth, self._w.innerHeight
                options = {'transparent':True, 'antialias':True, 'view':canvas}
                attachpoint = window.document.getElementById('graphics-column')
            else:
                #self._w = window.open("", "")
                # 在頁面直接執行時, 不另開視窗頁面
                self._w =window
                w, h = self._w.innerWidth * 0.9, self._w.innerHeight * 0.9
                options = {'transparent':True, 'antialias':True}
                attachpoint = self._w.document.body
            GFX.utils._saidHello = True; # ugly hack to block pixi banner
            self._stage = GFX_NewStage()
            self.width = width if width != 0 else int(w)
            self.height = height if height != 0 else int(h)
            self._renderer = GFX.autoDetectRenderer(self.width, self.height, options)
            attachpoint.appendChild(self._renderer.view)
            self._w.onunload = onclose
      
        def bind(self, evtspec, callback):
            self._w.document.body.unbind(evtspec) # in case already bound
            self._w.document.body.bind(evtspec, callback)

        def unbind(self, evtspec):
            self._w.document.body.unbind(evtspec)
          
        def add(self, obj):
            self._stage.addChild(obj)
          
        def remove(self, obj):
            self._stage.removeChild(obj)
          
        def animate(self, stepcallback):
            self._renderer.render(self._stage)
            self._w.requestAnimationFrame(stepcallback)
          
        def destroy(self):
            SND.all().stop()
            self._stage.destroy()
  

elif module_exists('pygame'):

    try:
        from ggame.pygamedeps import *
    except ImportError:
        from pygamedeps import *

else:
    try:
        from ggame.headlessdeps import *
    except ImportError:
        from headlessdeps import *
</pre>
<p>在 CMSimfly 頁面執行方式:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># Ggame
from ggame import App, ImageAsset, Sprite, MouseEvent
from random import random, randint
from browser import document as doc
from browser import html
import math
# 建立內定名稱為 "ggame-canvas" 的 canvas 標註
canvas = html.CANVAS(width = 600, height = 400)
canvas.id = "ggame-canvas"
brython_div = doc["brython_div"]
brython_div &lt;= canvas
# 建立名稱為 graphics-column 且 1x1 大小的 div 標註
graphics_column = html.DIV(width = 1, height = 1)
graphics_column.id = "graphics-column"
brython_div &lt;= graphics_column

class Bunny(Sprite):
    
    asset = ImageAsset("./../images/bunny.png")
    
    def __init__(self, position):
        super().__init__(Bunny.asset, position)
        # register mouse events
        App.listenMouseEvent(MouseEvent.mousedown, self.mousedown)
        App.listenMouseEvent(MouseEvent.mouseup, self.mouseup)
        App.listenMouseEvent(MouseEvent.mousemove, self.mousemove)
        self.dragging = True

    
    def step(self):
        # Every now and then a bunny hops...
        if random() &lt; 0.01:
            self.x += randint(-20,20)
            self.y += randint(-20,20)
        
        
    def mousedown(self, event):
        # capture any mouse down within 50 pixels
        self.deltax = event.x - (self.x + self.width//2) 
        self.deltay = event.y - (self.y + self.height//2)
        if abs(self.deltax) &lt; 50 and abs(self.deltay) &lt; 50:
            self.dragging = True
            # only drag one bunny at a time - consume the event
            event.consumed = True
            
    def mousemove(self, event):
        if self.dragging:
            self.x = event.x - self.deltax - self.width//2
            self.y = event.y - self.deltay - self.height//2
            event.consumed = True
            
    def mouseup(self, event):
        if self.dragging:
            self.dragging = False
            event.consumed = True
            
        
class DemoApp(App):
    
    def __init__(self):
        super().__init__()
        for i in range(5):
            Bunny((randint(50, 600), randint(50, 400)))
        
    def step(self):
        # Override step to perform action on each frame update
        for bunny in self.spritelist:
            bunny.step()


# Create the app
app = DemoApp()  
# Run the app
app.run()</pre>
<p>GFX = window.PIXI<br/>GFX_Rectangle = GFX.Rectangle.new<br/>GFX_Texture = GFX.Texture.new<br/>GFX_Texture_fromImage = GFX.Texture.fromImage.new<br/>GFX_Sprite = GFX.Sprite.new<br/>GFX_Graphics = GFX.Graphics.new()<br/>GFX_Text = GFX.Text.new<br/>GFX_NewStage = GFX.Container.new<br/>SND = window.buzz<br/>SND_Sound = SND.sound.new</p>
<p>class GFX_Window(object):</p>
<p>def __init__(self, width, height, onclose):</p>
<h4>app</h4>
<p>App</p>
<h4>sprite</h4>
<p>Sprite</p>
<h4>event</h4>
<p>KeyEvent, MouseEvent</p>
<h4>asset</h4>
<p>ImageAsset, TextAsset, CircleAsset, RectangleAsset<br/>PolygonAsset, LineAsset, EllipseAsset<br/>Frame, Color, LineStyle</p>
<h4>sound</h4>
<p>SoundAsset, Sound</p>
<h3>GCS</h3>
<h4>Geometric Constraint Solver in Javascript (Brython)</h4>
<p>In calculus, Newton's method is an iterative method for finding the roots of a differentiable function f, which are solutions to the equation f (x) = 0.</p>
<p>More specifically, in optimization, Newton's method is applied to the derivative f ′ of a twice-differentiable function f to find the roots of the derivative (solutions to f ′(x) = 0), also known as the stationary points of f. These solutions may be minima, maxima, or saddle points.</p>
<p><a href="https://en.wikipedia.org/wiki/Quasi-Newton_method">https://en.wikipedia.org/wiki/Quasi-Newton_method</a> </p>
<p><a href="https://en.wikipedia.org/wiki/Taylor_series">https://en.wikipedia.org/wiki/Taylor_series</a> </p>
<p>In mathematics, a Taylor series is a representation of a function as an infinite sum of terms that are calculated from the values of the function's derivatives at a single point. </p>
<p><a href="/downloads/Taylor%20series.pdf">taylor series.pdf</a></p>
<p><a href="https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm">https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm</a> </p>
<p><a href="/downloads/ON%20THE LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION.pdf">ON THE LIMITED MEMORY BFGS METHOD FOR LARGE SCALE OPTIMIZATION.pdf</a></p>
<p><a href="/downloads/Introduction%20to Numerical Methods with examples in Javascript.pdf">Introduction to Numerical Methods with examples in Javascript.pdf</a></p>
<p><a href="https://stats.stackexchange.com/questions/340555/advantages-disadvantages-of-bfgs-vs-l-bfgs-b-vs-port">https://stats.stackexchange.com/questions/340555/advantages-disadvantages-of-bfgs-vs-l-bfgs-b-vs-port</a> </p>
<p><a href="/downloads/BFGS_tutorial.pdf">bgfs_tutorial.pdf</a></p>
<p><a href="/downloads/A%20perfect example for the BFGS method.pdf">A perfect example for the BFGS method.pdf</a></p>
<p><a href="/downloads/minimization_constrainopt.pdf">minimization_constrainopt.pdf</a></p>
<h4>Javascript</h4>
<p><a href="https://github.com/optimization-js/optimization-js">https://github.com/optimization-js/optimization-js</a> </p>
<h4>optimization in python</h4>
<p>scipy 求最小化範例</p>
<p>安裝 scipy</p>
<p>pip install scipy</p>
<p><a href="/downloads/scipy_optimize.pdf">scipy_optimize.pdf</a></p>
<p><a href="/downloads/scipy_optimize2.pdf">scipy_optimize2.pdf</a></p>
<p><a href="/downloads/parameter_estimation.pdf">parameter_estimation.pdf</a></p>
<p>範例</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import scipy.optimize as optimize

def f(params):
    # print(params)  # &lt;-- you'll see that params is a NumPy array
    a, b, c = params # &lt;-- for readability you may wish to assign names to the component variables
    return a**2 + b**2 + c**2

initial_guess = [1, 1, 1]
result = optimize.minimize(f, initial_guess)
if result.success:
    fitted_params = result.x
    print(fitted_params)
else:
    raise ValueError(result.message)</pre>
<p>scipy 部分原始碼</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#__docformat__ = "restructuredtext en"
# ******NOTICE***************
# optimize.py module by Travis E. Oliphant
#
# You may copy and use this module as you see fit with no
# guarantee implied provided you keep this notice in all copies.
# *****END NOTICE************

# A collection of optimization algorithms.  Version 0.5
# CHANGES
#  Added fminbound (July 2001)
#  Added brute (Aug. 2002)
#  Finished line search satisfying strong Wolfe conditions (Mar. 2004)
#  Updated strong Wolfe conditions line search to use
#      cubic-interpolation (Mar. 2004)

from __future__ import division, print_function, absolute_import


# Minimization routines

__all__ = ['fmin', 'fmin_powell', 'fmin_bfgs', 'fmin_ncg', 'fmin_cg',
           'fminbound', 'brent', 'golden', 'bracket', 'rosen', 'rosen_der',
           'rosen_hess', 'rosen_hess_prod', 'brute', 'approx_fprime',
           'line_search', 'check_grad', 'OptimizeResult', 'show_options',
           'OptimizeWarning']

__docformat__ = "restructuredtext en"

import warnings
import sys
import numpy
from scipy._lib.six import callable, xrange
from numpy import (atleast_1d, eye, mgrid, argmin, zeros, shape, squeeze,
                   asarray, sqrt, Inf, asfarray, isinf)
import numpy as np
from .linesearch import (line_search_wolfe1, line_search_wolfe2,
                         line_search_wolfe2 as line_search,
                         LineSearchWarning)
from scipy._lib._util import getargspec_no_self as _getargspec
from scipy._lib._util import MapWrapper


# standard status messages of optimizers
_status_message = {'success': 'Optimization terminated successfully.',
                   'maxfev': 'Maximum number of function evaluations has '
                              'been exceeded.',
                   'maxiter': 'Maximum number of iterations has been '
                              'exceeded.',
                   'pr_loss': 'Desired error not necessarily achieved due '
                              'to precision loss.'}


class MemoizeJac(object):
    """ Decorator that caches the value gradient of function each time it
    is called. """
    def __init__(self, fun):
        self.fun = fun
        self.jac = None
        self.x = None

    def __call__(self, x, *args):
        self.x = numpy.asarray(x).copy()
        fg = self.fun(x, *args)
        self.jac = fg[1]
        return fg[0]

    def derivative(self, x, *args):
        if self.jac is not None and numpy.alltrue(x == self.x):
            return self.jac
        else:
            self(x, *args)
            return self.jac


class OptimizeResult(dict):
    """ Represents the optimization result.

    Attributes
    ----------
    x : ndarray
        The solution of the optimization.
    success : bool
        Whether or not the optimizer exited successfully.
    status : int
        Termination status of the optimizer. Its value depends on the
        underlying solver. Refer to `message` for details.
    message : str
        Description of the cause of the termination.
    fun, jac, hess: ndarray
        Values of objective function, its Jacobian and its Hessian (if
        available). The Hessians may be approximations, see the documentation
        of the function in question.
    hess_inv : object
        Inverse of the objective function's Hessian; may be an approximation.
        Not available for all solvers. The type of this attribute may be
        either np.ndarray or scipy.sparse.linalg.LinearOperator.
    nfev, njev, nhev : int
        Number of evaluations of the objective functions and of its
        Jacobian and Hessian.
    nit : int
        Number of iterations performed by the optimizer.
    maxcv : float
        The maximum constraint violation.

    Notes
    -----
    There may be additional attributes not listed above depending of the
    specific solver. Since this class is essentially a subclass of dict
    with attribute accessors, one can see which attributes are available
    using the `keys()` method.
    """
    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError:
            raise AttributeError(name)

    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

    def __repr__(self):
        if self.keys():
            m = max(map(len, list(self.keys()))) + 1
            return '\n'.join([k.rjust(m) + ': ' + repr(v)
                              for k, v in sorted(self.items())])
        else:
            return self.__class__.__name__ + "()"

    def __dir__(self):
        return list(self.keys())


class OptimizeWarning(UserWarning):
    pass


def _check_unknown_options(unknown_options):
    if unknown_options:
        msg = ", ".join(map(str, unknown_options.keys()))
        # Stack level 4: this is called from _minimize_*, which is
        # called from another function in SciPy. Level 4 is the first
        # level in user code.
        warnings.warn("Unknown solver options: %s" % msg, OptimizeWarning, 4)


def is_array_scalar(x):
    """Test whether `x` is either a scalar or an array scalar.

    """
    return np.size(x) == 1


_epsilon = sqrt(numpy.finfo(float).eps)


def vecnorm(x, ord=2):
    if ord == Inf:
        return numpy.amax(numpy.abs(x))
    elif ord == -Inf:
        return numpy.amin(numpy.abs(x))
    else:
        return numpy.sum(numpy.abs(x)**ord, axis=0)**(1.0 / ord)


def rosen(x):
    """
    The Rosenbrock function.

    The function computed is::

        sum(100.0*(x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0)

    Parameters
    ----------
    x : array_like
        1-D array of points at which the Rosenbrock function is to be computed.

    Returns
    -------
    f : float
        The value of the Rosenbrock function.

    See Also
    --------
    rosen_der, rosen_hess, rosen_hess_prod
    
    Examples
    --------
    &gt;&gt;&gt; from scipy.optimize import rosen
    &gt;&gt;&gt; X = 0.1 * np.arange(10)
    &gt;&gt;&gt; rosen(X)
    76.56

    """
    x = asarray(x)
    r = numpy.sum(100.0 * (x[1:] - x[:-1]**2.0)**2.0 + (1 - x[:-1])**2.0,
                  axis=0)
    return r


def rosen_der(x):
    """
    The derivative (i.e. gradient) of the Rosenbrock function.

    Parameters
    ----------
    x : array_like
        1-D array of points at which the derivative is to be computed.

    Returns
    -------
    rosen_der : (N,) ndarray
        The gradient of the Rosenbrock function at `x`.

    See Also
    --------
    rosen, rosen_hess, rosen_hess_prod
    
    Examples
    --------
    &gt;&gt;&gt; from scipy.optimize import rosen_der
    &gt;&gt;&gt; X = 0.1 * np.arange(9)
    &gt;&gt;&gt; rosen_der(X)
    array([ -2. ,  10.6,  15.6,  13.4,   6.4,  -3. , -12.4, -19.4,  62. ])
    
    """
    x = asarray(x)
    xm = x[1:-1]
    xm_m1 = x[:-2]
    xm_p1 = x[2:]
    der = numpy.zeros_like(x)
    der[1:-1] = (200 * (xm - xm_m1**2) -
                 400 * (xm_p1 - xm**2) * xm - 2 * (1 - xm))
    der[0] = -400 * x[0] * (x[1] - x[0]**2) - 2 * (1 - x[0])
    der[-1] = 200 * (x[-1] - x[-2]**2)
    return der


def rosen_hess(x):
    """
    The Hessian matrix of the Rosenbrock function.

    Parameters
    ----------
    x : array_like
        1-D array of points at which the Hessian matrix is to be computed.

    Returns
    -------
    rosen_hess : ndarray
        The Hessian matrix of the Rosenbrock function at `x`.

    See Also
    --------
    rosen, rosen_der, rosen_hess_prod
    
    Examples
    --------
    &gt;&gt;&gt; from scipy.optimize import rosen_hess
    &gt;&gt;&gt; X = 0.1 * np.arange(4)
    &gt;&gt;&gt; rosen_hess(X)
    array([[-38.,   0.,   0.,   0.],
           [  0., 134., -40.,   0.],
           [  0., -40., 130., -80.],
           [  0.,   0., -80., 200.]])
           
    """
    x = atleast_1d(x)
    H = numpy.diag(-400 * x[:-1], 1) - numpy.diag(400 * x[:-1], -1)
    diagonal = numpy.zeros(len(x), dtype=x.dtype)
    diagonal[0] = 1200 * x[0]**2 - 400 * x[1] + 2
    diagonal[-1] = 200
    diagonal[1:-1] = 202 + 1200 * x[1:-1]**2 - 400 * x[2:]
    H = H + numpy.diag(diagonal)
    return H


def rosen_hess_prod(x, p):
    """
    Product of the Hessian matrix of the Rosenbrock function with a vector.

    Parameters
    ----------
    x : array_like
        1-D array of points at which the Hessian matrix is to be computed.
    p : array_like
        1-D array, the vector to be multiplied by the Hessian matrix.

    Returns
    -------
    rosen_hess_prod : ndarray
        The Hessian matrix of the Rosenbrock function at `x` multiplied
        by the vector `p`.

    See Also
    --------
    rosen, rosen_der, rosen_hess
    
    Examples
    --------
    &gt;&gt;&gt; from scipy.optimize import rosen_hess_prod
    &gt;&gt;&gt; X = 0.1 * np.arange(9)
    &gt;&gt;&gt; p = 0.5 * np.arange(9) 
    &gt;&gt;&gt; rosen_hess_prod(X, p)
    array([  -0.,   27.,  -10.,  -95., -192., -265., -278., -195., -180.])
    
    """
    x = atleast_1d(x)
    Hp = numpy.zeros(len(x), dtype=x.dtype)
    Hp[0] = (1200 * x[0]**2 - 400 * x[1] + 2) * p[0] - 400 * x[0] * p[1]
    Hp[1:-1] = (-400 * x[:-2] * p[:-2] +
                (202 + 1200 * x[1:-1]**2 - 400 * x[2:]) * p[1:-1] -
                400 * x[1:-1] * p[2:])
    Hp[-1] = -400 * x[-2] * p[-2] + 200*p[-1]
    return Hp


def wrap_function(function, args):
    ncalls = [0]
    if function is None:
        return ncalls, None

    def function_wrapper(*wrapper_args):
        ncalls[0] += 1
        return function(*(wrapper_args + args))

    return ncalls, function_wrapper


def fmin(func, x0, args=(), xtol=1e-4, ftol=1e-4, maxiter=None, maxfun=None,
         full_output=0, disp=1, retall=0, callback=None, initial_simplex=None):
    """
    Minimize a function using the downhill simplex algorithm.

    This algorithm only uses function values, not derivatives or second
    derivatives.

    Parameters
    ----------
    func : callable func(x,*args)
        The objective function to be minimized.
    x0 : ndarray
        Initial guess.
    args : tuple, optional
        Extra arguments passed to func, i.e. ``f(x,*args)``.
    xtol : float, optional
        Absolute error in xopt between iterations that is acceptable for
        convergence.
    ftol : number, optional
        Absolute error in func(xopt) between iterations that is acceptable for
        convergence.
    maxiter : int, optional
        Maximum number of iterations to perform.
    maxfun : number, optional
        Maximum number of function evaluations to make.
    full_output : bool, optional
        Set to True if fopt and warnflag outputs are desired.
    disp : bool, optional
        Set to True to print convergence messages.
    retall : bool, optional
        Set to True to return list of solutions at each iteration.
    callback : callable, optional
        Called after each iteration, as callback(xk), where xk is the
        current parameter vector.
    initial_simplex : array_like of shape (N + 1, N), optional
        Initial simplex. If given, overrides `x0`.
        ``initial_simplex[j,:]`` should contain the coordinates of
        the j-th vertex of the ``N+1`` vertices in the simplex, where
        ``N`` is the dimension.

    Returns
    -------
    xopt : ndarray
        Parameter that minimizes function.
    fopt : float
        Value of function at minimum: ``fopt = func(xopt)``.
    iter : int
        Number of iterations performed.
    funcalls : int
        Number of function calls made.
    warnflag : int
        1 : Maximum number of function evaluations made.
        2 : Maximum number of iterations reached.
    allvecs : list
        Solution at each iteration.

    See also
    --------
    minimize: Interface to minimization algorithms for multivariate
        functions. See the 'Nelder-Mead' `method` in particular.

    Notes
    -----
    Uses a Nelder-Mead simplex algorithm to find the minimum of function of
    one or more variables.

    This algorithm has a long history of successful use in applications.
    But it will usually be slower than an algorithm that uses first or
    second derivative information. In practice it can have poor
    performance in high-dimensional problems and is not robust to
    minimizing complicated functions. Additionally, there currently is no
    complete theory describing when the algorithm will successfully
    converge to the minimum, or how fast it will if it does. Both the ftol and
    xtol criteria must be met for convergence.

    Examples
    --------
    &gt;&gt;&gt; def f(x):
    ...     return x**2

    &gt;&gt;&gt; from scipy import optimize

    &gt;&gt;&gt; minimum = optimize.fmin(f, 1)
    Optimization terminated successfully.
             Current function value: 0.000000
             Iterations: 17
             Function evaluations: 34
    &gt;&gt;&gt; minimum[0]
    -8.8817841970012523e-16

    References
    ----------
    .. [1] Nelder, J.A. and Mead, R. (1965), "A simplex method for function
           minimization", The Computer Journal, 7, pp. 308-313

    .. [2] Wright, M.H. (1996), "Direct Search Methods: Once Scorned, Now
           Respectable", in Numerical Analysis 1995, Proceedings of the
           1995 Dundee Biennial Conference in Numerical Analysis, D.F.
           Griffiths and G.A. Watson (Eds.), Addison Wesley Longman,
           Harlow, UK, pp. 191-208.

    """
    opts = {'xatol': xtol,
            'fatol': ftol,
            'maxiter': maxiter,
            'maxfev': maxfun,
            'disp': disp,
            'return_all': retall,
            'initial_simplex': initial_simplex}

    res = _minimize_neldermead(func, x0, args, callback=callback, **opts)
    if full_output:
        retlist = res['x'], res['fun'], res['nit'], res['nfev'], res['status']
        if retall:
            retlist += (res['allvecs'], )
        return retlist
    else:
        if retall:
            return res['x'], res['allvecs']
        else:
            return res['x']


def _minimize_neldermead(func, x0, args=(), callback=None,
                         maxiter=None, maxfev=None, disp=False,
                         return_all=False, initial_simplex=None,
                         xatol=1e-4, fatol=1e-4, adaptive=False,
                         **unknown_options):
    """
    Minimization of scalar function of one or more variables using the
    Nelder-Mead algorithm.

    Options
    -------
    disp : bool
        Set to True to print convergence messages.
    maxiter, maxfev : int
        Maximum allowed number of iterations and function evaluations.
        Will default to ``N*200``, where ``N`` is the number of
        variables, if neither `maxiter` or `maxfev` is set. If both
        `maxiter` and `maxfev` are set, minimization will stop at the
        first reached.
    initial_simplex : array_like of shape (N + 1, N)
        Initial simplex. If given, overrides `x0`.
        ``initial_simplex[j,:]`` should contain the coordinates of
        the j-th vertex of the ``N+1`` vertices in the simplex, where
        ``N`` is the dimension.
    xatol : float, optional
        Absolute error in xopt between iterations that is acceptable for
        convergence.
    fatol : number, optional
        Absolute error in func(xopt) between iterations that is acceptable for
        convergence.
    adaptive : bool, optional
        Adapt algorithm parameters to dimensionality of problem. Useful for
        high-dimensional minimization [1]_.

    References
    ----------
    .. [1] Gao, F. and Han, L.
       Implementing the Nelder-Mead simplex algorithm with adaptive
       parameters. 2012. Computational Optimization and Applications.
       51:1, pp. 259-277

    """
    if 'ftol' in unknown_options:
        warnings.warn("ftol is deprecated for Nelder-Mead,"
                      " use fatol instead. If you specified both, only"
                      " fatol is used.",
                      DeprecationWarning)
        if (np.isclose(fatol, 1e-4) and
                not np.isclose(unknown_options['ftol'], 1e-4)):
            # only ftol was probably specified, use it.
            fatol = unknown_options['ftol']
        unknown_options.pop('ftol')
    if 'xtol' in unknown_options:
        warnings.warn("xtol is deprecated for Nelder-Mead,"
                      " use xatol instead. If you specified both, only"
                      " xatol is used.",
                      DeprecationWarning)
        if (np.isclose(xatol, 1e-4) and
                not np.isclose(unknown_options['xtol'], 1e-4)):
            # only xtol was probably specified, use it.
            xatol = unknown_options['xtol']
        unknown_options.pop('xtol')

    _check_unknown_options(unknown_options)
    maxfun = maxfev
    retall = return_all

    fcalls, func = wrap_function(func, args)

    if adaptive:
        dim = float(len(x0))
        rho = 1
        chi = 1 + 2/dim
        psi = 0.75 - 1/(2*dim)
        sigma = 1 - 1/dim
    else:
        rho = 1
        chi = 2
        psi = 0.5
        sigma = 0.5

    nonzdelt = 0.05
    zdelt = 0.00025

    x0 = asfarray(x0).flatten()

    if initial_simplex is None:
        N = len(x0)

        sim = numpy.zeros((N + 1, N), dtype=x0.dtype)
        sim[0] = x0
        for k in range(N):
            y = numpy.array(x0, copy=True)
            if y[k] != 0:
                y[k] = (1 + nonzdelt)*y[k]
            else:
                y[k] = zdelt
            sim[k + 1] = y
    else:
        sim = np.asfarray(initial_simplex).copy()
        if sim.ndim != 2 or sim.shape[0] != sim.shape[1] + 1:
            raise ValueError("`initial_simplex` should be an array of shape (N+1,N)")
        if len(x0) != sim.shape[1]:
            raise ValueError("Size of `initial_simplex` is not consistent with `x0`")
        N = sim.shape[1]

    if retall:
        allvecs = [sim[0]]

    # If neither are set, then set both to default
    if maxiter is None and maxfun is None:
        maxiter = N * 200
        maxfun = N * 200
    elif maxiter is None:
        # Convert remaining Nones, to np.inf, unless the other is np.inf, in
        # which case use the default to avoid unbounded iteration
        if maxfun == np.inf:
            maxiter = N * 200
        else:
            maxiter = np.inf
    elif maxfun is None:
        if maxiter == np.inf:
            maxfun = N * 200
        else:
            maxfun = np.inf

    one2np1 = list(range(1, N + 1))
    fsim = numpy.zeros((N + 1,), float)

    for k in range(N + 1):
        fsim[k] = func(sim[k])

    ind = numpy.argsort(fsim)
    fsim = numpy.take(fsim, ind, 0)
    # sort so sim[0,:] has the lowest function value
    sim = numpy.take(sim, ind, 0)

    iterations = 1

    while (fcalls[0] &lt; maxfun and iterations &lt; maxiter):
        if (numpy.max(numpy.ravel(numpy.abs(sim[1:] - sim[0]))) &lt;= xatol and
                numpy.max(numpy.abs(fsim[0] - fsim[1:])) &lt;= fatol):
            break

        xbar = numpy.add.reduce(sim[:-1], 0) / N
        xr = (1 + rho) * xbar - rho * sim[-1]
        fxr = func(xr)
        doshrink = 0

        if fxr &lt; fsim[0]:
            xe = (1 + rho * chi) * xbar - rho * chi * sim[-1]
            fxe = func(xe)

            if fxe &lt; fxr:
                sim[-1] = xe
                fsim[-1] = fxe
            else:
                sim[-1] = xr
                fsim[-1] = fxr
        else:  # fsim[0] &lt;= fxr
            if fxr &lt; fsim[-2]:
                sim[-1] = xr
                fsim[-1] = fxr
            else:  # fxr &gt;= fsim[-2]
                # Perform contraction
                if fxr &lt; fsim[-1]:
                    xc = (1 + psi * rho) * xbar - psi * rho * sim[-1]
                    fxc = func(xc)

                    if fxc &lt;= fxr:
                        sim[-1] = xc
                        fsim[-1] = fxc
                    else:
                        doshrink = 1
                else:
                    # Perform an inside contraction
                    xcc = (1 - psi) * xbar + psi * sim[-1]
                    fxcc = func(xcc)

                    if fxcc &lt; fsim[-1]:
                        sim[-1] = xcc
                        fsim[-1] = fxcc
                    else:
                        doshrink = 1

                if doshrink:
                    for j in one2np1:
                        sim[j] = sim[0] + sigma * (sim[j] - sim[0])
                        fsim[j] = func(sim[j])

        ind = numpy.argsort(fsim)
        sim = numpy.take(sim, ind, 0)
        fsim = numpy.take(fsim, ind, 0)
        if callback is not None:
            callback(sim[0])
        iterations += 1
        if retall:
            allvecs.append(sim[0])

    x = sim[0]
    fval = numpy.min(fsim)
    warnflag = 0

    if fcalls[0] &gt;= maxfun:
        warnflag = 1
        msg = _status_message['maxfev']
        if disp:
            print('Warning: ' + msg)
    elif iterations &gt;= maxiter:
        warnflag = 2
        msg = _status_message['maxiter']
        if disp:
            print('Warning: ' + msg)
    else:
        msg = _status_message['success']
        if disp:
            print(msg)
            print("         Current function value: %f" % fval)
            print("         Iterations: %d" % iterations)
            print("         Function evaluations: %d" % fcalls[0])

    result = OptimizeResult(fun=fval, nit=iterations, nfev=fcalls[0],
                            status=warnflag, success=(warnflag == 0),
                            message=msg, x=x, final_simplex=(sim, fsim))
    if retall:
        result['allvecs'] = allvecs
    return result


def _approx_fprime_helper(xk, f, epsilon, args=(), f0=None):
    """
    See ``approx_fprime``.  An optional initial function value arg is added.

    """
    if f0 is None:
        f0 = f(*((xk,) + args))
    grad = numpy.zeros((len(xk),), float)
    ei = numpy.zeros((len(xk),), float)
    for k in range(len(xk)):
        ei[k] = 1.0
        d = epsilon * ei
        grad[k] = (f(*((xk + d,) + args)) - f0) / d[k]
        ei[k] = 0.0
    return grad


def approx_fprime(xk, f, epsilon, *args):
    """Finite-difference approximation of the gradient of a scalar function.

    Parameters
    ----------
    xk : array_like
        The coordinate vector at which to determine the gradient of `f`.
    f : callable
        The function of which to determine the gradient (partial derivatives).
        Should take `xk` as first argument, other arguments to `f` can be
        supplied in ``*args``.  Should return a scalar, the value of the
        function at `xk`.
    epsilon : array_like
        Increment to `xk` to use for determining the function gradient.
        If a scalar, uses the same finite difference delta for all partial
        derivatives.  If an array, should contain one value per element of
        `xk`.
    \\*args : args, optional
        Any other arguments that are to be passed to `f`.

    Returns
    -------
    grad : ndarray
        The partial derivatives of `f` to `xk`.

    See Also
    --------
    check_grad : Check correctness of gradient function against approx_fprime.

    Notes
    -----
    The function gradient is determined by the forward finite difference
    formula::

                 f(xk[i] + epsilon[i]) - f(xk[i])
        f'[i] = ---------------------------------
                            epsilon[i]

    The main use of `approx_fprime` is in scalar function optimizers like
    `fmin_bfgs`, to determine numerically the Jacobian of a function.

    Examples
    --------
    &gt;&gt;&gt; from scipy import optimize
    &gt;&gt;&gt; def func(x, c0, c1):
    ...     "Coordinate vector `x` should be an array of size two."
    ...     return c0 * x[0]**2 + c1*x[1]**2

    &gt;&gt;&gt; x = np.ones(2)
    &gt;&gt;&gt; c0, c1 = (1, 200)
    &gt;&gt;&gt; eps = np.sqrt(np.finfo(float).eps)
    &gt;&gt;&gt; optimize.approx_fprime(x, func, [eps, np.sqrt(200) * eps], c0, c1)
    array([   2.        ,  400.00004198])

    """
    return _approx_fprime_helper(xk, f, epsilon, args=args)


def check_grad(func, grad, x0, *args, **kwargs):
    """Check the correctness of a gradient function by comparing it against a
    (forward) finite-difference approximation of the gradient.

    Parameters
    ----------
    func : callable ``func(x0, *args)``
        Function whose derivative is to be checked.
    grad : callable ``grad(x0, *args)``
        Gradient of `func`.
    x0 : ndarray
        Points to check `grad` against forward difference approximation of grad
        using `func`.
    args : \\*args, optional
        Extra arguments passed to `func` and `grad`.
    epsilon : float, optional
        Step size used for the finite difference approximation. It defaults to
        ``sqrt(numpy.finfo(float).eps)``, which is approximately 1.49e-08.

    Returns
    -------
    err : float
        The square root of the sum of squares (i.e. the 2-norm) of the
        difference between ``grad(x0, *args)`` and the finite difference
        approximation of `grad` using func at the points `x0`.

    See Also
    --------
    approx_fprime

    Examples
    --------
    &gt;&gt;&gt; def func(x):
    ...     return x[0]**2 - 0.5 * x[1]**3
    &gt;&gt;&gt; def grad(x):
    ...     return [2 * x[0], -1.5 * x[1]**2]
    &gt;&gt;&gt; from scipy.optimize import check_grad
    &gt;&gt;&gt; check_grad(func, grad, [1.5, -1.5])
    2.9802322387695312e-08

    """
    step = kwargs.pop('epsilon', _epsilon)
    if kwargs:
        raise ValueError("Unknown keyword arguments: %r" %
                         (list(kwargs.keys()),))
    return sqrt(sum((grad(x0, *args) -
                     approx_fprime(x0, func, step, *args))**2))


def approx_fhess_p(x0, p, fprime, epsilon, *args):
    f2 = fprime(*((x0 + epsilon*p,) + args))
    f1 = fprime(*((x0,) + args))
    return (f2 - f1) / epsilon


class _LineSearchError(RuntimeError):
    pass


def _line_search_wolfe12(f, fprime, xk, pk, gfk, old_fval, old_old_fval,
                         **kwargs):
    """
    Same as line_search_wolfe1, but fall back to line_search_wolfe2 if
    suitable step length is not found, and raise an exception if a
    suitable step length is not found.

    Raises
    ------
    _LineSearchError
        If no suitable step size is found

    """

    extra_condition = kwargs.pop('extra_condition', None)

    ret = line_search_wolfe1(f, fprime, xk, pk, gfk,
                             old_fval, old_old_fval,
                             **kwargs)

    if ret[0] is not None and extra_condition is not None:
        xp1 = xk + ret[0] * pk
        if not extra_condition(ret[0], xp1, ret[3], ret[5]):
            # Reject step if extra_condition fails
            ret = (None,)

    if ret[0] is None:
        # line search failed: try different one.
        with warnings.catch_warnings():
            warnings.simplefilter('ignore', LineSearchWarning)
            kwargs2 = {}
            for key in ('c1', 'c2', 'amax'):
                if key in kwargs:
                    kwargs2[key] = kwargs[key]
            ret = line_search_wolfe2(f, fprime, xk, pk, gfk,
                                     old_fval, old_old_fval,
                                     extra_condition=extra_condition,
                                     **kwargs2)

    if ret[0] is None:
        raise _LineSearchError()

    return ret


def fmin_bfgs(f, x0, fprime=None, args=(), gtol=1e-5, norm=Inf,
              epsilon=_epsilon, maxiter=None, full_output=0, disp=1,
              retall=0, callback=None):
    """
    Minimize a function using the BFGS algorithm.

    Parameters
    ----------
    f : callable f(x,*args)
        Objective function to be minimized.
    x0 : ndarray
        Initial guess.
    fprime : callable f'(x,*args), optional
        Gradient of f.
    args : tuple, optional
        Extra arguments passed to f and fprime.
    gtol : float, optional
        Gradient norm must be less than gtol before successful termination.
    norm : float, optional
        Order of norm (Inf is max, -Inf is min)
    epsilon : int or ndarray, optional
        If fprime is approximated, use this value for the step size.
    callback : callable, optional
        An optional user-supplied function to call after each
        iteration.  Called as callback(xk), where xk is the
        current parameter vector.
    maxiter : int, optional
        Maximum number of iterations to perform.
    full_output : bool, optional
        If True,return fopt, func_calls, grad_calls, and warnflag
        in addition to xopt.
    disp : bool, optional
        Print convergence message if True.
    retall : bool, optional
        Return a list of results at each iteration if True.

    Returns
    -------
    xopt : ndarray
        Parameters which minimize f, i.e. f(xopt) == fopt.
    fopt : float
        Minimum value.
    gopt : ndarray
        Value of gradient at minimum, f'(xopt), which should be near 0.
    Bopt : ndarray
        Value of 1/f''(xopt), i.e. the inverse hessian matrix.
    func_calls : int
        Number of function_calls made.
    grad_calls : int
        Number of gradient calls made.
    warnflag : integer
        1 : Maximum number of iterations exceeded.
        2 : Gradient and/or function calls not changing.
    allvecs  :  list
        The value of xopt at each iteration.  Only returned if retall is True.

    See also
    --------
    minimize: Interface to minimization algorithms for multivariate
        functions. See the 'BFGS' `method` in particular.

    Notes
    -----
    Optimize the function, f, whose gradient is given by fprime
    using the quasi-Newton method of Broyden, Fletcher, Goldfarb,
    and Shanno (BFGS)

    References
    ----------
    Wright, and Nocedal 'Numerical Optimization', 1999, pg. 198.

    """
    opts = {'gtol': gtol,
            'norm': norm,
            'eps': epsilon,
            'disp': disp,
            'maxiter': maxiter,
            'return_all': retall}

    res = _minimize_bfgs(f, x0, args, fprime, callback=callback, **opts)

    if full_output:
        retlist = (res['x'], res['fun'], res['jac'], res['hess_inv'],
                   res['nfev'], res['njev'], res['status'])
        if retall:
            retlist += (res['allvecs'], )
        return retlist
    else:
        if retall:
            return res['x'], res['allvecs']
        else:
            return res['x']


def _minimize_bfgs(fun, x0, args=(), jac=None, callback=None,
                   gtol=1e-5, norm=Inf, eps=_epsilon, maxiter=None,
                   disp=False, return_all=False,
                   **unknown_options):
    """
    Minimization of scalar function of one or more variables using the
    BFGS algorithm.

    Options
    -------
    disp : bool
        Set to True to print convergence messages.
    maxiter : int
        Maximum number of iterations to perform.
    gtol : float
        Gradient norm must be less than `gtol` before successful
        termination.
    norm : float
        Order of norm (Inf is max, -Inf is min).
    eps : float or ndarray
        If `jac` is approximated, use this value for the step size.

    """
    _check_unknown_options(unknown_options)
    f = fun
    fprime = jac
    epsilon = eps
    retall = return_all

    x0 = asarray(x0).flatten()
    if x0.ndim == 0:
        x0.shape = (1,)
    if maxiter is None:
        maxiter = len(x0) * 200
    func_calls, f = wrap_function(f, args)
    if fprime is None:
        grad_calls, myfprime = wrap_function(approx_fprime, (f, epsilon))
    else:
        grad_calls, myfprime = wrap_function(fprime, args)
    gfk = myfprime(x0)
    k = 0
    N = len(x0)
    I = numpy.eye(N, dtype=int)
    Hk = I

    # Sets the initial step guess to dx ~ 1
    old_fval = f(x0)
    old_old_fval = old_fval + np.linalg.norm(gfk) / 2

    xk = x0
    if retall:
        allvecs = [x0]
    warnflag = 0
    gnorm = vecnorm(gfk, ord=norm)
    while (gnorm &gt; gtol) and (k &lt; maxiter):
        pk = -numpy.dot(Hk, gfk)
        try:
            alpha_k, fc, gc, old_fval, old_old_fval, gfkp1 = \
                     _line_search_wolfe12(f, myfprime, xk, pk, gfk,
                                          old_fval, old_old_fval, amin=1e-100, amax=1e100)
        except _LineSearchError:
            # Line search failed to find a better solution.
            warnflag = 2
            break

        xkp1 = xk + alpha_k * pk
        if retall:
            allvecs.append(xkp1)
        sk = xkp1 - xk
        xk = xkp1
        if gfkp1 is None:
            gfkp1 = myfprime(xkp1)

        yk = gfkp1 - gfk
        gfk = gfkp1
        if callback is not None:
            callback(xk)
        k += 1
        gnorm = vecnorm(gfk, ord=norm)
        if (gnorm &lt;= gtol):
            break

        if not numpy.isfinite(old_fval):
            # We correctly found +-Inf as optimal value, or something went
            # wrong.
            warnflag = 2
            break

        try:  # this was handled in numeric, let it remaines for more safety
            rhok = 1.0 / (numpy.dot(yk, sk))
        except ZeroDivisionError:
            rhok = 1000.0
            if disp:
                print("Divide-by-zero encountered: rhok assumed large")
        if isinf(rhok):  # this is patch for numpy
            rhok = 1000.0
            if disp:
                print("Divide-by-zero encountered: rhok assumed large")
        A1 = I - sk[:, numpy.newaxis] * yk[numpy.newaxis, :] * rhok
        A2 = I - yk[:, numpy.newaxis] * sk[numpy.newaxis, :] * rhok
        Hk = numpy.dot(A1, numpy.dot(Hk, A2)) + (rhok * sk[:, numpy.newaxis] *
                                                 sk[numpy.newaxis, :])

    fval = old_fval
    if np.isnan(fval):
        # This can happen if the first call to f returned NaN;
        # the loop is then never entered.
        warnflag = 2

    if warnflag == 2:
        msg = _status_message['pr_loss']
    elif k &gt;= maxiter:
        warnflag = 1
        msg = _status_message['maxiter']
    else:
        msg = _status_message['success']

    if disp:
        print("%s%s" % ("Warning: " if warnflag != 0 else "", msg))
        print("         Current function value: %f" % fval)
        print("         Iterations: %d" % k)
        print("         Function evaluations: %d" % func_calls[0])
        print("         Gradient evaluations: %d" % grad_calls[0])

    result = OptimizeResult(fun=fval, jac=gfk, hess_inv=Hk, nfev=func_calls[0],
                            njev=grad_calls[0], status=warnflag,
                            success=(warnflag == 0), message=msg, x=xk,
                            nit=k)
    if retall:
        result['allvecs'] = allvecs
    return result


def fmin_cg(f, x0, fprime=None, args=(), gtol=1e-5, norm=Inf, epsilon=_epsilon,
            maxiter=None, full_output=0, disp=1, retall=0, callback=None):
    """
    Minimize a function using a nonlinear conjugate gradient algorithm.

    Parameters
    ----------
    f : callable, ``f(x, *args)``
        Objective function to be minimized.  Here `x` must be a 1-D array of
        the variables that are to be changed in the search for a minimum, and
        `args` are the other (fixed) parameters of `f`.
    x0 : ndarray
        A user-supplied initial estimate of `xopt`, the optimal value of `x`.
        It must be a 1-D array of values.
    fprime : callable, ``fprime(x, *args)``, optional
        A function that returns the gradient of `f` at `x`. Here `x` and `args`
        are as described above for `f`. The returned value must be a 1-D array.
        Defaults to None, in which case the gradient is approximated
        numerically (see `epsilon`, below).
    args : tuple, optional
        Parameter values passed to `f` and `fprime`. Must be supplied whenever
        additional fixed parameters are needed to completely specify the
        functions `f` and `fprime`.
    gtol : float, optional
        Stop when the norm of the gradient is less than `gtol`.
    norm : float, optional
        Order to use for the norm of the gradient
        (``-np.Inf`` is min, ``np.Inf`` is max).
    epsilon : float or ndarray, optional
        Step size(s) to use when `fprime` is approximated numerically. Can be a
        scalar or a 1-D array.  Defaults to ``sqrt(eps)``, with eps the
        floating point machine precision.  Usually ``sqrt(eps)`` is about
        1.5e-8.
    maxiter : int, optional
        Maximum number of iterations to perform. Default is ``200 * len(x0)``.
    full_output : bool, optional
        If True, return `fopt`, `func_calls`, `grad_calls`, and `warnflag` in
        addition to `xopt`.  See the Returns section below for additional
        information on optional return values.
    disp : bool, optional
        If True, return a convergence message, followed by `xopt`.
    retall : bool, optional
        If True, add to the returned values the results of each iteration.
    callback : callable, optional
        An optional user-supplied function, called after each iteration.
        Called as ``callback(xk)``, where ``xk`` is the current value of `x0`.

    Returns
    -------
    xopt : ndarray
        Parameters which minimize f, i.e. ``f(xopt) == fopt``.
    fopt : float, optional
        Minimum value found, f(xopt).  Only returned if `full_output` is True.
    func_calls : int, optional
        The number of function_calls made.  Only returned if `full_output`
        is True.
    grad_calls : int, optional
        The number of gradient calls made. Only returned if `full_output` is
        True.
    warnflag : int, optional
        Integer value with warning status, only returned if `full_output` is
        True.

        0 : Success.

        1 : The maximum number of iterations was exceeded.

        2 : Gradient and/or function calls were not changing.  May indicate
            that precision was lost, i.e., the routine did not converge.

    allvecs : list of ndarray, optional
        List of arrays, containing the results at each iteration.
        Only returned if `retall` is True.

    See Also
    --------
    minimize : common interface to all `scipy.optimize` algorithms for
               unconstrained and constrained minimization of multivariate
               functions.  It provides an alternative way to call
               ``fmin_cg``, by specifying ``method='CG'``.

    Notes
    -----
    This conjugate gradient algorithm is based on that of Polak and Ribiere
    [1]_.

    Conjugate gradient methods tend to work better when:

    1. `f` has a unique global minimizing point, and no local minima or
       other stationary points,
    2. `f` is, at least locally, reasonably well approximated by a
       quadratic function of the variables,
    3. `f` is continuous and has a continuous gradient,
    4. `fprime` is not too large, e.g., has a norm less than 1000,
    5. The initial guess, `x0`, is reasonably close to `f` 's global
       minimizing point, `xopt`.

    References
    ----------
    .. [1] Wright &amp; Nocedal, "Numerical Optimization", 1999, pp. 120-122.

    Examples
    --------
    Example 1: seek the minimum value of the expression
    ``a*u**2 + b*u*v + c*v**2 + d*u + e*v + f`` for given values
    of the parameters and an initial guess ``(u, v) = (0, 0)``.

    &gt;&gt;&gt; args = (2, 3, 7, 8, 9, 10)  # parameter values
    &gt;&gt;&gt; def f(x, *args):
    ...     u, v = x
    ...     a, b, c, d, e, f = args
    ...     return a*u**2 + b*u*v + c*v**2 + d*u + e*v + f
    &gt;&gt;&gt; def gradf(x, *args):
    ...     u, v = x
    ...     a, b, c, d, e, f = args
    ...     gu = 2*a*u + b*v + d     # u-component of the gradient
    ...     gv = b*u + 2*c*v + e     # v-component of the gradient
    ...     return np.asarray((gu, gv))
    &gt;&gt;&gt; x0 = np.asarray((0, 0))  # Initial guess.
    &gt;&gt;&gt; from scipy import optimize
    &gt;&gt;&gt; res1 = optimize.fmin_cg(f, x0, fprime=gradf, args=args)
    Optimization terminated successfully.
             Current function value: 1.617021
             Iterations: 4
             Function evaluations: 8
             Gradient evaluations: 8
    &gt;&gt;&gt; res1
    array([-1.80851064, -0.25531915])

    Example 2: solve the same problem using the `minimize` function.
    (This `myopts` dictionary shows all of the available options,
    although in practice only non-default values would be needed.
    The returned value will be a dictionary.)

    &gt;&gt;&gt; opts = {'maxiter' : None,    # default value.
    ...         'disp' : True,    # non-default value.
    ...         'gtol' : 1e-5,    # default value.
    ...         'norm' : np.inf,  # default value.
    ...         'eps' : 1.4901161193847656e-08}  # default value.
    &gt;&gt;&gt; res2 = optimize.minimize(f, x0, jac=gradf, args=args,
    ...                          method='CG', options=opts)
    Optimization terminated successfully.
            Current function value: 1.617021
            Iterations: 4
            Function evaluations: 8
            Gradient evaluations: 8
    &gt;&gt;&gt; res2.x  # minimum found
    array([-1.80851064, -0.25531915])

    """
    opts = {'gtol': gtol,
            'norm': norm,
            'eps': epsilon,
            'disp': disp,
            'maxiter': maxiter,
            'return_all': retall}

    res = _minimize_cg(f, x0, args, fprime, callback=callback, **opts)

    if full_output:
        retlist = res['x'], res['fun'], res['nfev'], res['njev'], res['status']
        if retall:
            retlist += (res['allvecs'], )
        return retlist
    else:
        if retall:
            return res['x'], res['allvecs']
        else:
            return res['x']


def _minimize_cg(fun, x0, args=(), jac=None, callback=None,
                 gtol=1e-5, norm=Inf, eps=_epsilon, maxiter=None,
                 disp=False, return_all=False,
                 **unknown_options):
    """
    Minimization of scalar function of one or more variables using the
    conjugate gradient algorithm.

    Options
    -------
    disp : bool
        Set to True to print convergence messages.
    maxiter : int
        Maximum number of iterations to perform.
    gtol : float
        Gradient norm must be less than `gtol` before successful
        termination.
    norm : float
        Order of norm (Inf is max, -Inf is min).
    eps : float or ndarray
        If `jac` is approximated, use this value for the step size.

    """
    _check_unknown_options(unknown_options)
    f = fun
    fprime = jac
    epsilon = eps
    retall = return_all

    x0 = asarray(x0).flatten()
    if maxiter is None:
        maxiter = len(x0) * 200
    func_calls, f = wrap_function(f, args)
    if fprime is None:
        grad_calls, myfprime = wrap_function(approx_fprime, (f, epsilon))
    else:
        grad_calls, myfprime = wrap_function(fprime, args)
    gfk = myfprime(x0)
    k = 0
    xk = x0

    # Sets the initial step guess to dx ~ 1
    old_fval = f(xk)
    old_old_fval = old_fval + np.linalg.norm(gfk) / 2

    if retall:
        allvecs = [xk]
    warnflag = 0
    pk = -gfk
    gnorm = vecnorm(gfk, ord=norm)

    sigma_3 = 0.01

    while (gnorm &gt; gtol) and (k &lt; maxiter):
        deltak = numpy.dot(gfk, gfk)

        cached_step = [None]

        def polak_ribiere_powell_step(alpha, gfkp1=None):
            xkp1 = xk + alpha * pk
            if gfkp1 is None:
                gfkp1 = myfprime(xkp1)
            yk = gfkp1 - gfk
            beta_k = max(0, numpy.dot(yk, gfkp1) / deltak)
            pkp1 = -gfkp1 + beta_k * pk
            gnorm = vecnorm(gfkp1, ord=norm)
            return (alpha, xkp1, pkp1, gfkp1, gnorm)

        def descent_condition(alpha, xkp1, fp1, gfkp1):
            # Polak-Ribiere+ needs an explicit check of a sufficient
            # descent condition, which is not guaranteed by strong Wolfe.
            #
            # See Gilbert &amp; Nocedal, "Global convergence properties of
            # conjugate gradient methods for optimization",
            # SIAM J. Optimization 2, 21 (1992).
            cached_step[:] = polak_ribiere_powell_step(alpha, gfkp1)
            alpha, xk, pk, gfk, gnorm = cached_step

            # Accept step if it leads to convergence.
            if gnorm &lt;= gtol:
                return True

            # Accept step if sufficient descent condition applies.
            return numpy.dot(pk, gfk) &lt;= -sigma_3 * numpy.dot(gfk, gfk)

        try:
            alpha_k, fc, gc, old_fval, old_old_fval, gfkp1 = \
                     _line_search_wolfe12(f, myfprime, xk, pk, gfk, old_fval,
                                          old_old_fval, c2=0.4, amin=1e-100, amax=1e100,
                                          extra_condition=descent_condition)
        except _LineSearchError:
            # Line search failed to find a better solution.
            warnflag = 2
            break

        # Reuse already computed results if possible
        if alpha_k == cached_step[0]:
            alpha_k, xk, pk, gfk, gnorm = cached_step
        else:
            alpha_k, xk, pk, gfk, gnorm = polak_ribiere_powell_step(alpha_k, gfkp1)

        if retall:
            allvecs.append(xk)
        if callback is not None:
            callback(xk)
        k += 1

    fval = old_fval
    if warnflag == 2:
        msg = _status_message['pr_loss']
    elif k &gt;= maxiter:
        warnflag = 1
        msg = _status_message['maxiter']
    else:
        msg = _status_message['success']

    if disp:
        print("%s%s" % ("Warning: " if warnflag != 0 else "", msg))
        print("         Current function value: %f" % fval)
        print("         Iterations: %d" % k)
        print("         Function evaluations: %d" % func_calls[0])
        print("         Gradient evaluations: %d" % grad_calls[0])

    result = OptimizeResult(fun=fval, jac=gfk, nfev=func_calls[0],
                            njev=grad_calls[0], status=warnflag,
                            success=(warnflag == 0), message=msg, x=xk,
                            nit=k)
    if retall:
        result['allvecs'] = allvecs
    return result


def fmin_ncg(f, x0, fprime, fhess_p=None, fhess=None, args=(), avextol=1e-5,
             epsilon=_epsilon, maxiter=None, full_output=0, disp=1, retall=0,
             callback=None):
    """
    Unconstrained minimization of a function using the Newton-CG method.

    Parameters
    ----------
    f : callable ``f(x, *args)``
        Objective function to be minimized.
    x0 : ndarray
        Initial guess.
    fprime : callable ``f'(x, *args)``
        Gradient of f.
    fhess_p : callable ``fhess_p(x, p, *args)``, optional
        Function which computes the Hessian of f times an
        arbitrary vector, p.
    fhess : callable ``fhess(x, *args)``, optional
        Function to compute the Hessian matrix of f.
    args : tuple, optional
        Extra arguments passed to f, fprime, fhess_p, and fhess
        (the same set of extra arguments is supplied to all of
        these functions).
    epsilon : float or ndarray, optional
        If fhess is approximated, use this value for the step size.
    callback : callable, optional
        An optional user-supplied function which is called after
        each iteration.  Called as callback(xk), where xk is the
        current parameter vector.
    avextol : float, optional
        Convergence is assumed when the average relative error in
        the minimizer falls below this amount.
    maxiter : int, optional
        Maximum number of iterations to perform.
    full_output : bool, optional
        If True, return the optional outputs.
    disp : bool, optional
        If True, print convergence message.
    retall : bool, optional
        If True, return a list of results at each iteration.

    Returns
    -------
    xopt : ndarray
        Parameters which minimize f, i.e. ``f(xopt) == fopt``.
    fopt : float
        Value of the function at xopt, i.e. ``fopt = f(xopt)``.
    fcalls : int
        Number of function calls made.
    gcalls : int
        Number of gradient calls made.
    hcalls : int
        Number of hessian calls made.
    warnflag : int
        Warnings generated by the algorithm.
        1 : Maximum number of iterations exceeded.
    allvecs : list
        The result at each iteration, if retall is True (see below).

    See also
    --------
    minimize: Interface to minimization algorithms for multivariate
        functions. See the 'Newton-CG' `method` in particular.

    Notes
    -----
    Only one of `fhess_p` or `fhess` need to be given.  If `fhess`
    is provided, then `fhess_p` will be ignored.  If neither `fhess`
    nor `fhess_p` is provided, then the hessian product will be
    approximated using finite differences on `fprime`. `fhess_p`
    must compute the hessian times an arbitrary vector. If it is not
    given, finite-differences on `fprime` are used to compute
    it.

    Newton-CG methods are also called truncated Newton methods. This
    function differs from scipy.optimize.fmin_tnc because

    1. scipy.optimize.fmin_ncg is written purely in python using numpy
        and scipy while scipy.optimize.fmin_tnc calls a C function.
    2. scipy.optimize.fmin_ncg is only for unconstrained minimization
        while scipy.optimize.fmin_tnc is for unconstrained minimization
        or box constrained minimization. (Box constraints give
        lower and upper bounds for each variable separately.)

    References
    ----------
    Wright &amp; Nocedal, 'Numerical Optimization', 1999, pg. 140.

    """
    opts = {'xtol': avextol,
            'eps': epsilon,
            'maxiter': maxiter,
            'disp': disp,
            'return_all': retall}

    res = _minimize_newtoncg(f, x0, args, fprime, fhess, fhess_p,
                             callback=callback, **opts)

    if full_output:
        retlist = (res['x'], res['fun'], res['nfev'], res['njev'],
                   res['nhev'], res['status'])
        if retall:
            retlist += (res['allvecs'], )
        return retlist
    else:
        if retall:
            return res['x'], res['allvecs']
        else:
            return res['x']


def _minimize_newtoncg(fun, x0, args=(), jac=None, hess=None, hessp=None,
                       callback=None, xtol=1e-5, eps=_epsilon, maxiter=None,
                       disp=False, return_all=False,
                       **unknown_options):
    """
    Minimization of scalar function of one or more variables using the
    Newton-CG algorithm.

    Note that the `jac` parameter (Jacobian) is required.

    Options
    -------
    disp : bool
        Set to True to print convergence messages.
    xtol : float
        Average relative error in solution `xopt` acceptable for
        convergence.
    maxiter : int
        Maximum number of iterations to perform.
    eps : float or ndarray
        If `jac` is approximated, use this value for the step size.

    """
    _check_unknown_options(unknown_options)
    if jac is None:
        raise ValueError('Jacobian is required for Newton-CG method')
    f = fun
    fprime = jac
    fhess_p = hessp
    fhess = hess
    avextol = xtol
    epsilon = eps
    retall = return_all

    def terminate(warnflag, msg):
        if disp:
            print(msg)
            print("         Current function value: %f" % old_fval)
            print("         Iterations: %d" % k)
            print("         Function evaluations: %d" % fcalls[0])
            print("         Gradient evaluations: %d" % gcalls[0])
            print("         Hessian evaluations: %d" % hcalls)
        fval = old_fval
        result = OptimizeResult(fun=fval, jac=gfk, nfev=fcalls[0],
                                njev=gcalls[0], nhev=hcalls, status=warnflag,
                                success=(warnflag == 0), message=msg, x=xk,
                                nit=k)
        if retall:
            result['allvecs'] = allvecs
        return result

    x0 = asarray(x0).flatten()
    fcalls, f = wrap_function(f, args)
    gcalls, fprime = wrap_function(fprime, args)
    hcalls = 0
    if maxiter is None:
        maxiter = len(x0)*200
    cg_maxiter = 20*len(x0)

    xtol = len(x0) * avextol
    update = [2 * xtol]
    xk = x0
    if retall:
        allvecs = [xk]
    k = 0
    gfk = None
    old_fval = f(x0)
    old_old_fval = None
    float64eps = numpy.finfo(numpy.float64).eps
    while numpy.add.reduce(numpy.abs(update)) &gt; xtol:
        if k &gt;= maxiter:
            msg = "Warning: " + _status_message['maxiter']
            return terminate(1, msg)
        # Compute a search direction pk by applying the CG method to
        #  del2 f(xk) p = - grad f(xk) starting from 0.
        b = -fprime(xk)
        maggrad = numpy.add.reduce(numpy.abs(b))
        eta = numpy.min([0.5, numpy.sqrt(maggrad)])
        termcond = eta * maggrad
        xsupi = zeros(len(x0), dtype=x0.dtype)
        ri = -b
        psupi = -ri
        i = 0
        dri0 = numpy.dot(ri, ri)

        if fhess is not None:             # you want to compute hessian once.
            A = fhess(*(xk,) + args)
            hcalls = hcalls + 1

        for k2 in xrange(cg_maxiter):
            if numpy.add.reduce(numpy.abs(ri)) &lt;= termcond:
                break
            if fhess is None:
                if fhess_p is None:
                    Ap = approx_fhess_p(xk, psupi, fprime, epsilon)
                else:
                    Ap = fhess_p(xk, psupi, *args)
                    hcalls = hcalls + 1
            else:
                Ap = numpy.dot(A, psupi)
            # check curvature
            Ap = asarray(Ap).squeeze()  # get rid of matrices...
            curv = numpy.dot(psupi, Ap)
            if 0 &lt;= curv &lt;= 3 * float64eps:
                break
            elif curv &lt; 0:
                if (i &gt; 0):
                    break
                else:
                    # fall back to steepest descent direction
                    xsupi = dri0 / (-curv) * b
                    break
            alphai = dri0 / curv
            xsupi = xsupi + alphai * psupi
            ri = ri + alphai * Ap
            dri1 = numpy.dot(ri, ri)
            betai = dri1 / dri0
            psupi = -ri + betai * psupi
            i = i + 1
            dri0 = dri1          # update numpy.dot(ri,ri) for next time.
        else:
            # curvature keeps increasing, bail out
            msg = ("Warning: CG iterations didn't converge.  The Hessian is not "
                   "positive definite.")
            return terminate(3, msg)

        pk = xsupi  # search direction is solution to system.
        gfk = -b    # gradient at xk

        try:
            alphak, fc, gc, old_fval, old_old_fval, gfkp1 = \
                     _line_search_wolfe12(f, fprime, xk, pk, gfk,
                                          old_fval, old_old_fval)
        except _LineSearchError:
            # Line search failed to find a better solution.
            msg = "Warning: " + _status_message['pr_loss']
            return terminate(2, msg)

        update = alphak * pk
        xk = xk + update        # upcast if necessary
        if callback is not None:
            callback(xk)
        if retall:
            allvecs.append(xk)
        k += 1
    else:
        msg = _status_message['success']
        return terminate(0, msg)


def fminbound(func, x1, x2, args=(), xtol=1e-5, maxfun=500,
              full_output=0, disp=1):
    """Bounded minimization for scalar functions.

    Parameters
    ----------
    func : callable f(x,*args)
        Objective function to be minimized (must accept and return scalars).
    x1, x2 : float or array scalar
        The optimization bounds.
    args : tuple, optional
        Extra arguments passed to function.
    xtol : float, optional
        The convergence tolerance.
    maxfun : int, optional
        Maximum number of function evaluations allowed.
    full_output : bool, optional
        If True, return optional outputs.
    disp : int, optional
        If non-zero, print messages.
            0 : no message printing.
            1 : non-convergence notification messages only.
            2 : print a message on convergence too.
            3 : print iteration results.


    Returns
    -------
    xopt : ndarray
        Parameters (over given interval) which minimize the
        objective function.
    fval : number
        The function value at the minimum point.
    ierr : int
        An error flag (0 if converged, 1 if maximum number of
        function calls reached).
    numfunc : int
      The number of function calls made.

    See also
    --------
    minimize_scalar: Interface to minimization algorithms for scalar
        univariate functions. See the 'Bounded' `method` in particular.

    Notes
    -----
    Finds a local minimizer of the scalar function `func` in the
    interval x1 &lt; xopt &lt; x2 using Brent's method.  (See `brent`
    for auto-bracketing).

    Examples
    --------
    `fminbound` finds the minimum of the function in the given range.
    The following examples illustrate the same

    &gt;&gt;&gt; def f(x):
    ...     return x**2

    &gt;&gt;&gt; from scipy import optimize

    &gt;&gt;&gt; minimum = optimize.fminbound(f, -1, 2)
    &gt;&gt;&gt; minimum
    0.0
    &gt;&gt;&gt; minimum = optimize.fminbound(f, 1, 2)
    &gt;&gt;&gt; minimum
    1.0000059608609866
    """
    options = {'xatol': xtol,
               'maxiter': maxfun,
               'disp': disp}

    res = _minimize_scalar_bounded(func, (x1, x2), args, **options)
    if full_output:
        return res['x'], res['fun'], res['status'], res['nfev']
    else:
        return res['x']


def _minimize_scalar_bounded(func, bounds, args=(),
                             xatol=1e-5, maxiter=500, disp=0,
                             **unknown_options):
    """
    Options
    -------
    maxiter : int
        Maximum number of iterations to perform.
    disp: int, optional
        If non-zero, print messages.
            0 : no message printing.
            1 : non-convergence notification messages only.
            2 : print a message on convergence too.
            3 : print iteration results.
    xatol : float
        Absolute error in solution `xopt` acceptable for convergence.

    """
    _check_unknown_options(unknown_options)
    maxfun = maxiter
    # Test bounds are of correct form
    if len(bounds) != 2:
        raise ValueError('bounds must have two elements.')
    x1, x2 = bounds

    if not (is_array_scalar(x1) and is_array_scalar(x2)):
        raise ValueError("Optimisation bounds must be scalars"
                         " or array scalars.")
    if x1 &gt; x2:
        raise ValueError("The lower bound exceeds the upper bound.")

    flag = 0
    header = ' Func-count     x          f(x)          Procedure'
    step = '       initial'

    sqrt_eps = sqrt(2.2e-16)
    golden_mean = 0.5 * (3.0 - sqrt(5.0))
    a, b = x1, x2
    fulc = a + golden_mean * (b - a)
    nfc, xf = fulc, fulc
    rat = e = 0.0
    x = xf
    fx = func(x, *args)
    num = 1
    fmin_data = (1, xf, fx)

    ffulc = fnfc = fx
    xm = 0.5 * (a + b)
    tol1 = sqrt_eps * numpy.abs(xf) + xatol / 3.0
    tol2 = 2.0 * tol1

    if disp &gt; 2:
        print(" ")
        print(header)
        print("%5.0f   %12.6g %12.6g %s" % (fmin_data + (step,)))

    while (numpy.abs(xf - xm) &gt; (tol2 - 0.5 * (b - a))):
        golden = 1
        # Check for parabolic fit
        if numpy.abs(e) &gt; tol1:
            golden = 0
            r = (xf - nfc) * (fx - ffulc)
            q = (xf - fulc) * (fx - fnfc)
            p = (xf - fulc) * q - (xf - nfc) * r
            q = 2.0 * (q - r)
            if q &gt; 0.0:
                p = -p
            q = numpy.abs(q)
            r = e
            e = rat

            # Check for acceptability of parabola
            if ((numpy.abs(p) &lt; numpy.abs(0.5*q*r)) and (p &gt; q*(a - xf)) and
                    (p &lt; q * (b - xf))):
                rat = (p + 0.0) / q
                x = xf + rat
                step = '       parabolic'

                if ((x - a) &lt; tol2) or ((b - x) &lt; tol2):
                    si = numpy.sign(xm - xf) + ((xm - xf) == 0)
                    rat = tol1 * si
            else:      # do a golden section step
                golden = 1

        if golden:  # Do a golden-section step
            if xf &gt;= xm:
                e = a - xf
            else:
                e = b - xf
            rat = golden_mean*e
            step = '       golden'

        si = numpy.sign(rat) + (rat == 0)
        x = xf + si * numpy.max([numpy.abs(rat), tol1])
        fu = func(x, *args)
        num += 1
        fmin_data = (num, x, fu)
        if disp &gt; 2:
            print("%5.0f   %12.6g %12.6g %s" % (fmin_data + (step,)))

        if fu &lt;= fx:
            if x &gt;= xf:
                a = xf
            else:
                b = xf
            fulc, ffulc = nfc, fnfc
            nfc, fnfc = xf, fx
            xf, fx = x, fu
        else:
            if x &lt; xf:
                a = x
            else:
                b = x
            if (fu &lt;= fnfc) or (nfc == xf):
                fulc, ffulc = nfc, fnfc
                nfc, fnfc = x, fu
            elif (fu &lt;= ffulc) or (fulc == xf) or (fulc == nfc):
                fulc, ffulc = x, fu

        xm = 0.5 * (a + b)
        tol1 = sqrt_eps * numpy.abs(xf) + xatol / 3.0
        tol2 = 2.0 * tol1

        if num &gt;= maxfun:
            flag = 1
            break

    fval = fx
    if disp &gt; 0:
        _endprint(x, flag, fval, maxfun, xatol, disp)

    result = OptimizeResult(fun=fval, status=flag, success=(flag == 0),
                            message={0: 'Solution found.',
                                     1: 'Maximum number of function calls '
                                        'reached.'}.get(flag, ''),
                            x=xf, nfev=num)

    return result


class Brent:
    #need to rethink design of __init__
    def __init__(self, func, args=(), tol=1.48e-8, maxiter=500,
                 full_output=0):
        self.func = func
        self.args = args
        self.tol = tol
        self.maxiter = maxiter
        self._mintol = 1.0e-11
        self._cg = 0.3819660
        self.xmin = None
        self.fval = None
        self.iter = 0
        self.funcalls = 0

    # need to rethink design of set_bracket (new options, etc)
    def set_bracket(self, brack=None):
        self.brack = brack

    def get_bracket_info(self):
        #set up
        func = self.func
        args = self.args
        brack = self.brack
        ### BEGIN core bracket_info code ###
        ### carefully DOCUMENT any CHANGES in core ##
        if brack is None:
            xa, xb, xc, fa, fb, fc, funcalls = bracket(func, args=args)
        elif len(brack) == 2:
            xa, xb, xc, fa, fb, fc, funcalls = bracket(func, xa=brack[0],
                                                       xb=brack[1], args=args)
        elif len(brack) == 3:
            xa, xb, xc = brack
            if (xa &gt; xc):  # swap so xa &lt; xc can be assumed
                xc, xa = xa, xc
            if not ((xa &lt; xb) and (xb &lt; xc)):
                raise ValueError("Not a bracketing interval.")
            fa = func(*((xa,) + args))
            fb = func(*((xb,) + args))
            fc = func(*((xc,) + args))
            if not ((fb &lt; fa) and (fb &lt; fc)):
                raise ValueError("Not a bracketing interval.")
            funcalls = 3
        else:
            raise ValueError("Bracketing interval must be "
                             "length 2 or 3 sequence.")
        ### END core bracket_info code ###

        return xa, xb, xc, fa, fb, fc, funcalls

    def optimize(self):
        # set up for optimization
        func = self.func
        xa, xb, xc, fa, fb, fc, funcalls = self.get_bracket_info()
        _mintol = self._mintol
        _cg = self._cg
        #################################
        #BEGIN CORE ALGORITHM
        #################################
        x = w = v = xb
        fw = fv = fx = func(*((x,) + self.args))
        if (xa &lt; xc):
            a = xa
            b = xc
        else:
            a = xc
            b = xa
        deltax = 0.0
        funcalls += 1
        iter = 0
        while (iter &lt; self.maxiter):
            tol1 = self.tol * numpy.abs(x) + _mintol
            tol2 = 2.0 * tol1
            xmid = 0.5 * (a + b)
            # check for convergence
            if numpy.abs(x - xmid) &lt; (tol2 - 0.5 * (b - a)):
                break
            # XXX In the first iteration, rat is only bound in the true case
            # of this conditional. This used to cause an UnboundLocalError
            # (gh-4140). It should be set before the if (but to what?).
            if (numpy.abs(deltax) &lt;= tol1):
                if (x &gt;= xmid):
                    deltax = a - x       # do a golden section step
                else:
                    deltax = b - x
                rat = _cg * deltax
            else:                              # do a parabolic step
                tmp1 = (x - w) * (fx - fv)
                tmp2 = (x - v) * (fx - fw)
                p = (x - v) * tmp2 - (x - w) * tmp1
                tmp2 = 2.0 * (tmp2 - tmp1)
                if (tmp2 &gt; 0.0):
                    p = -p
                tmp2 = numpy.abs(tmp2)
                dx_temp = deltax
                deltax = rat
                # check parabolic fit
                if ((p &gt; tmp2 * (a - x)) and (p &lt; tmp2 * (b - x)) and
                        (numpy.abs(p) &lt; numpy.abs(0.5 * tmp2 * dx_temp))):
                    rat = p * 1.0 / tmp2        # if parabolic step is useful.
                    u = x + rat
                    if ((u - a) &lt; tol2 or (b - u) &lt; tol2):
                        if xmid - x &gt;= 0:
                            rat = tol1
                        else:
                            rat = -tol1
                else:
                    if (x &gt;= xmid):
                        deltax = a - x  # if it's not do a golden section step
                    else:
                        deltax = b - x
                    rat = _cg * deltax

            if (numpy.abs(rat) &lt; tol1):            # update by at least tol1
                if rat &gt;= 0:
                    u = x + tol1
                else:
                    u = x - tol1
            else:
                u = x + rat
            fu = func(*((u,) + self.args))      # calculate new output value
            funcalls += 1

            if (fu &gt; fx):                 # if it's bigger than current
                if (u &lt; x):
                    a = u
                else:
                    b = u
                if (fu &lt;= fw) or (w == x):
                    v = w
                    w = u
                    fv = fw
                    fw = fu
                elif (fu &lt;= fv) or (v == x) or (v == w):
                    v = u
                    fv = fu
            else:
                if (u &gt;= x):
                    a = x
                else:
                    b = x
                v = w
                w = x
                x = u
                fv = fw
                fw = fx
                fx = fu

            iter += 1
        #################################
        #END CORE ALGORITHM
        #################################

        self.xmin = x
        self.fval = fx
        self.iter = iter
        self.funcalls = funcalls

    def get_result(self, full_output=False):
        if full_output:
            return self.xmin, self.fval, self.iter, self.funcalls
        else:
            return self.xmin


def brent(func, args=(), brack=None, tol=1.48e-8, full_output=0, maxiter=500):
    """
    Given a function of one-variable and a possible bracket, return
    the local minimum of the function isolated to a fractional precision
    of tol.

    Parameters
    ----------
    func : callable f(x,*args)
        Objective function.
    args : tuple, optional
        Additional arguments (if present).
    brack : tuple, optional
        Either a triple (xa,xb,xc) where xa&lt;xb&lt;xc and func(xb) &lt;
        func(xa), func(xc) or a pair (xa,xb) which are used as a
        starting interval for a downhill bracket search (see
        `bracket`). Providing the pair (xa,xb) does not always mean
        the obtained solution will satisfy xa&lt;=x&lt;=xb.
    tol : float, optional
        Stop if between iteration change is less than `tol`.
    full_output : bool, optional
        If True, return all output args (xmin, fval, iter,
        funcalls).
    maxiter : int, optional
        Maximum number of iterations in solution.

    Returns
    -------
    xmin : ndarray
        Optimum point.
    fval : float
        Optimum value.
    iter : int
        Number of iterations.
    funcalls : int
        Number of objective function evaluations made.

    See also
    --------
    minimize_scalar: Interface to minimization algorithms for scalar
        univariate functions. See the 'Brent' `method` in particular.

    Notes
    -----
    Uses inverse parabolic interpolation when possible to speed up
    convergence of golden section method.

    Does not ensure that the minimum lies in the range specified by
    `brack`. See `fminbound`.

    Examples
    --------
    We illustrate the behaviour of the function when `brack` is of
    size 2 and 3 respectively. In the case where `brack` is of the
    form (xa,xb), we can see for the given values, the output need
    not necessarily lie in the range (xa,xb).

    &gt;&gt;&gt; def f(x):
    ...     return x**2

    &gt;&gt;&gt; from scipy import optimize

    &gt;&gt;&gt; minimum = optimize.brent(f,brack=(1,2))
    &gt;&gt;&gt; minimum
    0.0
    &gt;&gt;&gt; minimum = optimize.brent(f,brack=(-1,0.5,2))
    &gt;&gt;&gt; minimum
    -2.7755575615628914e-17

    """
    options = {'xtol': tol,
               'maxiter': maxiter}
    res = _minimize_scalar_brent(func, brack, args, **options)
    if full_output:
        return res['x'], res['fun'], res['nit'], res['nfev']
    else:
        return res['x']


def _minimize_scalar_brent(func, brack=None, args=(),
                           xtol=1.48e-8, maxiter=500,
                           **unknown_options):
    """
    Options
    -------
    maxiter : int
        Maximum number of iterations to perform.
    xtol : float
        Relative error in solution `xopt` acceptable for convergence.

    Notes
    -----
    Uses inverse parabolic interpolation when possible to speed up
    convergence of golden section method.

    """
    _check_unknown_options(unknown_options)
    tol = xtol
    if tol &lt; 0:
        raise ValueError('tolerance should be &gt;= 0, got %r' % tol)

    brent = Brent(func=func, args=args, tol=tol,
                  full_output=True, maxiter=maxiter)
    brent.set_bracket(brack)
    brent.optimize()
    x, fval, nit, nfev = brent.get_result(full_output=True)
    return OptimizeResult(fun=fval, x=x, nit=nit, nfev=nfev,
                          success=nit &lt; maxiter)


def golden(func, args=(), brack=None, tol=_epsilon,
           full_output=0, maxiter=5000):
    """
    Return the minimum of a function of one variable using golden section
    method.

    Given a function of one variable and a possible bracketing interval,
    return the minimum of the function isolated to a fractional precision of
    tol.

    Parameters
    ----------
    func : callable func(x,*args)
        Objective function to minimize.
    args : tuple, optional
        Additional arguments (if present), passed to func.
    brack : tuple, optional
        Triple (a,b,c), where (a&lt;b&lt;c) and func(b) &lt;
        func(a),func(c).  If bracket consists of two numbers (a,
        c), then they are assumed to be a starting interval for a
        downhill bracket search (see `bracket`); it doesn't always
        mean that obtained solution will satisfy a&lt;=x&lt;=c.
    tol : float, optional
        x tolerance stop criterion
    full_output : bool, optional
        If True, return optional outputs.
    maxiter : int
        Maximum number of iterations to perform.

    See also
    --------
    minimize_scalar: Interface to minimization algorithms for scalar
        univariate functions. See the 'Golden' `method` in particular.

    Notes
    -----
    Uses analog of bisection method to decrease the bracketed
    interval.

    Examples
    --------
    We illustrate the behaviour of the function when `brack` is of
    size 2 and 3 respectively. In the case where `brack` is of the
    form (xa,xb), we can see for the given values, the output need
    not necessarily lie in the range ``(xa, xb)``.

    &gt;&gt;&gt; def f(x):
    ...     return x**2

    &gt;&gt;&gt; from scipy import optimize

    &gt;&gt;&gt; minimum = optimize.golden(f, brack=(1, 2))
    &gt;&gt;&gt; minimum
    1.5717277788484873e-162
    &gt;&gt;&gt; minimum = optimize.golden(f, brack=(-1, 0.5, 2))
    &gt;&gt;&gt; minimum
    -1.5717277788484873e-162

    """
    options = {'xtol': tol, 'maxiter': maxiter}
    res = _minimize_scalar_golden(func, brack, args, **options)
    if full_output:
        return res['x'], res['fun'], res['nfev']
    else:
        return res['x']


def _minimize_scalar_golden(func, brack=None, args=(),
                            xtol=_epsilon, maxiter=5000, **unknown_options):
    """
    Options
    -------
    maxiter : int
        Maximum number of iterations to perform.
    xtol : float
        Relative error in solution `xopt` acceptable for convergence.

    """
    _check_unknown_options(unknown_options)
    tol = xtol
    if brack is None:
        xa, xb, xc, fa, fb, fc, funcalls = bracket(func, args=args)
    elif len(brack) == 2:
        xa, xb, xc, fa, fb, fc, funcalls = bracket(func, xa=brack[0],
                                                   xb=brack[1], args=args)
    elif len(brack) == 3:
        xa, xb, xc = brack
        if (xa &gt; xc):  # swap so xa &lt; xc can be assumed
            xc, xa = xa, xc
        if not ((xa &lt; xb) and (xb &lt; xc)):
            raise ValueError("Not a bracketing interval.")
        fa = func(*((xa,) + args))
        fb = func(*((xb,) + args))
        fc = func(*((xc,) + args))
        if not ((fb &lt; fa) and (fb &lt; fc)):
            raise ValueError("Not a bracketing interval.")
        funcalls = 3
    else:
        raise ValueError("Bracketing interval must be length 2 or 3 sequence.")

    _gR = 0.61803399  # golden ratio conjugate: 2.0/(1.0+sqrt(5.0))
    _gC = 1.0 - _gR
    x3 = xc
    x0 = xa
    if (numpy.abs(xc - xb) &gt; numpy.abs(xb - xa)):
        x1 = xb
        x2 = xb + _gC * (xc - xb)
    else:
        x2 = xb
        x1 = xb - _gC * (xb - xa)
    f1 = func(*((x1,) + args))
    f2 = func(*((x2,) + args))
    funcalls += 2
    nit = 0
    for i in xrange(maxiter):
        if numpy.abs(x3 - x0) &lt;= tol * (numpy.abs(x1) + numpy.abs(x2)):
            break
        if (f2 &lt; f1):
            x0 = x1
            x1 = x2
            x2 = _gR * x1 + _gC * x3
            f1 = f2
            f2 = func(*((x2,) + args))
        else:
            x3 = x2
            x2 = x1
            x1 = _gR * x2 + _gC * x0
            f2 = f1
            f1 = func(*((x1,) + args))
        funcalls += 1
        nit += 1
    if (f1 &lt; f2):
        xmin = x1
        fval = f1
    else:
        xmin = x2
        fval = f2

    return OptimizeResult(fun=fval, nfev=funcalls, x=xmin, nit=nit,
                          success=nit &lt; maxiter)


def bracket(func, xa=0.0, xb=1.0, args=(), grow_limit=110.0, maxiter=1000):
    """
    Bracket the minimum of the function.

    Given a function and distinct initial points, search in the
    downhill direction (as defined by the initital points) and return
    new points xa, xb, xc that bracket the minimum of the function
    f(xa) &gt; f(xb) &lt; f(xc). It doesn't always mean that obtained
    solution will satisfy xa&lt;=x&lt;=xb

    Parameters
    ----------
    func : callable f(x,*args)
        Objective function to minimize.
    xa, xb : float, optional
        Bracketing interval. Defaults `xa` to 0.0, and `xb` to 1.0.
    args : tuple, optional
        Additional arguments (if present), passed to `func`.
    grow_limit : float, optional
        Maximum grow limit.  Defaults to 110.0
    maxiter : int, optional
        Maximum number of iterations to perform. Defaults to 1000.

    Returns
    -------
    xa, xb, xc : float
        Bracket.
    fa, fb, fc : float
        Objective function values in bracket.
    funcalls : int
        Number of function evaluations made.

    """
    _gold = 1.618034  # golden ratio: (1.0+sqrt(5.0))/2.0
    _verysmall_num = 1e-21
    fa = func(*(xa,) + args)
    fb = func(*(xb,) + args)
    if (fa &lt; fb):                      # Switch so fa &gt; fb
        xa, xb = xb, xa
        fa, fb = fb, fa
    xc = xb + _gold * (xb - xa)
    fc = func(*((xc,) + args))
    funcalls = 3
    iter = 0
    while (fc &lt; fb):
        tmp1 = (xb - xa) * (fb - fc)
        tmp2 = (xb - xc) * (fb - fa)
        val = tmp2 - tmp1
        if numpy.abs(val) &lt; _verysmall_num:
            denom = 2.0 * _verysmall_num
        else:
            denom = 2.0 * val
        w = xb - ((xb - xc) * tmp2 - (xb - xa) * tmp1) / denom
        wlim = xb + grow_limit * (xc - xb)
        if iter &gt; maxiter:
            raise RuntimeError("Too many iterations.")
        iter += 1
        if (w - xc) * (xb - w) &gt; 0.0:
            fw = func(*((w,) + args))
            funcalls += 1
            if (fw &lt; fc):
                xa = xb
                xb = w
                fa = fb
                fb = fw
                return xa, xb, xc, fa, fb, fc, funcalls
            elif (fw &gt; fb):
                xc = w
                fc = fw
                return xa, xb, xc, fa, fb, fc, funcalls
            w = xc + _gold * (xc - xb)
            fw = func(*((w,) + args))
            funcalls += 1
        elif (w - wlim)*(wlim - xc) &gt;= 0.0:
            w = wlim
            fw = func(*((w,) + args))
            funcalls += 1
        elif (w - wlim)*(xc - w) &gt; 0.0:
            fw = func(*((w,) + args))
            funcalls += 1
            if (fw &lt; fc):
                xb = xc
                xc = w
                w = xc + _gold * (xc - xb)
                fb = fc
                fc = fw
                fw = func(*((w,) + args))
                funcalls += 1
        else:
            w = xc + _gold * (xc - xb)
            fw = func(*((w,) + args))
            funcalls += 1
        xa = xb
        xb = xc
        xc = w
        fa = fb
        fb = fc
        fc = fw
    return xa, xb, xc, fa, fb, fc, funcalls


def _linesearch_powell(func, p, xi, tol=1e-3):
    """Line-search algorithm using fminbound.

    Find the minimium of the function ``func(x0+ alpha*direc)``.

    """
    def myfunc(alpha):
        return func(p + alpha*xi)
    alpha_min, fret, iter, num = brent(myfunc, full_output=1, tol=tol)
    xi = alpha_min*xi
    return squeeze(fret), p + xi, xi


def fmin_powell(func, x0, args=(), xtol=1e-4, ftol=1e-4, maxiter=None,
                maxfun=None, full_output=0, disp=1, retall=0, callback=None,
                direc=None):
    """
    Minimize a function using modified Powell's method. This method
    only uses function values, not derivatives.

    Parameters
    ----------
    func : callable f(x,*args)
        Objective function to be minimized.
    x0 : ndarray
        Initial guess.
    args : tuple, optional
        Extra arguments passed to func.
    callback : callable, optional
        An optional user-supplied function, called after each
        iteration.  Called as ``callback(xk)``, where ``xk`` is the
        current parameter vector.
    direc : ndarray, optional
        Initial direction set.
    xtol : float, optional
        Line-search error tolerance.
    ftol : float, optional
        Relative error in ``func(xopt)`` acceptable for convergence.
    maxiter : int, optional
        Maximum number of iterations to perform.
    maxfun : int, optional
        Maximum number of function evaluations to make.
    full_output : bool, optional
        If True, fopt, xi, direc, iter, funcalls, and
        warnflag are returned.
    disp : bool, optional
        If True, print convergence messages.
    retall : bool, optional
        If True, return a list of the solution at each iteration.

    Returns
    -------
    xopt : ndarray
        Parameter which minimizes `func`.
    fopt : number
        Value of function at minimum: ``fopt = func(xopt)``.
    direc : ndarray
        Current direction set.
    iter : int
        Number of iterations.
    funcalls : int
        Number of function calls made.
    warnflag : int
        Integer warning flag:
            1 : Maximum number of function evaluations.
            2 : Maximum number of iterations.
    allvecs : list
        List of solutions at each iteration.

    See also
    --------
    minimize: Interface to unconstrained minimization algorithms for
        multivariate functions. See the 'Powell' `method` in particular.

    Notes
    -----
    Uses a modification of Powell's method to find the minimum of
    a function of N variables. Powell's method is a conjugate
    direction method.

    The algorithm has two loops. The outer loop
    merely iterates over the inner loop. The inner loop minimizes
    over each current direction in the direction set. At the end
    of the inner loop, if certain conditions are met, the direction
    that gave the largest decrease is dropped and replaced with
    the difference between the current estimated x and the estimated
    x from the beginning of the inner-loop.

    The technical conditions for replacing the direction of greatest
    increase amount to checking that

    1. No further gain can be made along the direction of greatest increase
       from that iteration.
    2. The direction of greatest increase accounted for a large sufficient
       fraction of the decrease in the function value from that iteration of
       the inner loop.

    Examples
    --------
    &gt;&gt;&gt; def f(x):
    ...     return x**2

    &gt;&gt;&gt; from scipy import optimize

    &gt;&gt;&gt; minimum = optimize.fmin_powell(f, -1)
    Optimization terminated successfully.
             Current function value: 0.000000
             Iterations: 2
             Function evaluations: 18
    &gt;&gt;&gt; minimum
    array(0.0)

    References
    ----------
    Powell M.J.D. (1964) An efficient method for finding the minimum of a
    function of several variables without calculating derivatives,
    Computer Journal, 7 (2):155-162.

    Press W., Teukolsky S.A., Vetterling W.T., and Flannery B.P.:
    Numerical Recipes (any edition), Cambridge University Press

    """
    opts = {'xtol': xtol,
            'ftol': ftol,
            'maxiter': maxiter,
            'maxfev': maxfun,
            'disp': disp,
            'direc': direc,
            'return_all': retall}

    res = _minimize_powell(func, x0, args, callback=callback, **opts)

    if full_output:
        retlist = (res['x'], res['fun'], res['direc'], res['nit'],
                   res['nfev'], res['status'])
        if retall:
            retlist += (res['allvecs'], )
        return retlist
    else:
        if retall:
            return res['x'], res['allvecs']
        else:
            return res['x']


def _minimize_powell(func, x0, args=(), callback=None,
                     xtol=1e-4, ftol=1e-4, maxiter=None, maxfev=None,
                     disp=False, direc=None, return_all=False,
                     **unknown_options):
    """
    Minimization of scalar function of one or more variables using the
    modified Powell algorithm.

    Options
    -------
    disp : bool
        Set to True to print convergence messages.
    xtol : float
        Relative error in solution `xopt` acceptable for convergence.
    ftol : float
        Relative error in ``fun(xopt)`` acceptable for convergence.
    maxiter, maxfev : int
        Maximum allowed number of iterations and function evaluations.
        Will default to ``N*1000``, where ``N`` is the number of
        variables, if neither `maxiter` or `maxfev` is set. If both
        `maxiter` and `maxfev` are set, minimization will stop at the
        first reached.
    direc : ndarray
        Initial set of direction vectors for the Powell method.

    """
    _check_unknown_options(unknown_options)
    maxfun = maxfev
    retall = return_all
    # we need to use a mutable object here that we can update in the
    # wrapper function
    fcalls, func = wrap_function(func, args)
    x = asarray(x0).flatten()
    if retall:
        allvecs = [x]
    N = len(x)
    # If neither are set, then set both to default
    if maxiter is None and maxfun is None:
        maxiter = N * 1000
        maxfun = N * 1000
    elif maxiter is None:
        # Convert remaining Nones, to np.inf, unless the other is np.inf, in
        # which case use the default to avoid unbounded iteration
        if maxfun == np.inf:
            maxiter = N * 1000
        else:
            maxiter = np.inf
    elif maxfun is None:
        if maxiter == np.inf:
            maxfun = N * 1000
        else:
            maxfun = np.inf

    if direc is None:
        direc = eye(N, dtype=float)
    else:
        direc = asarray(direc, dtype=float)

    fval = squeeze(func(x))
    x1 = x.copy()
    iter = 0
    ilist = list(range(N))
    while True:
        fx = fval
        bigind = 0
        delta = 0.0
        for i in ilist:
            direc1 = direc[i]
            fx2 = fval
            fval, x, direc1 = _linesearch_powell(func, x, direc1,
                                                 tol=xtol * 100)
            if (fx2 - fval) &gt; delta:
                delta = fx2 - fval
                bigind = i
        iter += 1
        if callback is not None:
            callback(x)
        if retall:
            allvecs.append(x)
        bnd = ftol * (numpy.abs(fx) + numpy.abs(fval)) + 1e-20
        if 2.0 * (fx - fval) &lt;= bnd:
            break
        if fcalls[0] &gt;= maxfun:
            break
        if iter &gt;= maxiter:
            break

        # Construct the extrapolated point
        direc1 = x - x1
        x2 = 2*x - x1
        x1 = x.copy()
        fx2 = squeeze(func(x2))

        if (fx &gt; fx2):
            t = 2.0*(fx + fx2 - 2.0*fval)
            temp = (fx - fval - delta)
            t *= temp*temp
            temp = fx - fx2
            t -= delta*temp*temp
            if t &lt; 0.0:
                fval, x, direc1 = _linesearch_powell(func, x, direc1,
                                                     tol=xtol*100)
                direc[bigind] = direc[-1]
                direc[-1] = direc1

    warnflag = 0
    if fcalls[0] &gt;= maxfun:
        warnflag = 1
        msg = _status_message['maxfev']
        if disp:
            print("Warning: " + msg)
    elif iter &gt;= maxiter:
        warnflag = 2
        msg = _status_message['maxiter']
        if disp:
            print("Warning: " + msg)
    else:
        msg = _status_message['success']
        if disp:
            print(msg)
            print("         Current function value: %f" % fval)
            print("         Iterations: %d" % iter)
            print("         Function evaluations: %d" % fcalls[0])

    x = squeeze(x)

    result = OptimizeResult(fun=fval, direc=direc, nit=iter, nfev=fcalls[0],
                            status=warnflag, success=(warnflag == 0),
                            message=msg, x=x)
    if retall:
        result['allvecs'] = allvecs
    return result


def _endprint(x, flag, fval, maxfun, xtol, disp):
    if flag == 0:
        if disp &gt; 1:
            print("\nOptimization terminated successfully;\n"
                  "The returned value satisfies the termination criteria\n"
                  "(using xtol = ", xtol, ")")
    if flag == 1:
        if disp:
            print("\nMaximum number of function evaluations exceeded --- "
                  "increase maxfun argument.\n")
    return


def brute(func, ranges, args=(), Ns=20, full_output=0, finish=fmin,
          disp=False, workers=1):
    """Minimize a function over a given range by brute force.

    Uses the "brute force" method, i.e. computes the function's value
    at each point of a multidimensional grid of points, to find the global
    minimum of the function.

    The function is evaluated everywhere in the range with the datatype of the
    first call to the function, as enforced by the ``vectorize`` NumPy
    function.  The value and type of the function evaluation returned when
    ``full_output=True`` are affected in addition by the ``finish`` argument
    (see Notes).

    The brute force approach is inefficient because the number of grid points
    increases exponentially - the number of grid points to evaluate is
    ``Ns ** len(x)``. Consequently, even with coarse grid spacing, even
    moderately sized problems can take a long time to run, and/or run into
    memory limitations.

    Parameters
    ----------
    func : callable
        The objective function to be minimized. Must be in the
        form ``f(x, *args)``, where ``x`` is the argument in
        the form of a 1-D array and ``args`` is a tuple of any
        additional fixed parameters needed to completely specify
        the function.
    ranges : tuple
        Each component of the `ranges` tuple must be either a
        "slice object" or a range tuple of the form ``(low, high)``.
        The program uses these to create the grid of points on which
        the objective function will be computed. See `Note 2` for
        more detail.
    args : tuple, optional
        Any additional fixed parameters needed to completely specify
        the function.
    Ns : int, optional
        Number of grid points along the axes, if not otherwise
        specified. See `Note2`.
    full_output : bool, optional
        If True, return the evaluation grid and the objective function's
        values on it.
    finish : callable, optional
        An optimization function that is called with the result of brute force
        minimization as initial guess.  `finish` should take `func` and
        the initial guess as positional arguments, and take `args` as
        keyword arguments.  It may additionally take `full_output`
        and/or `disp` as keyword arguments.  Use None if no "polishing"
        function is to be used. See Notes for more details.
    disp : bool, optional
        Set to True to print convergence messages from the `finish` callable.
    workers : int or map-like callable, optional
        If `workers` is an int the grid is subdivided into `workers`
        sections and evaluated in parallel (uses `multiprocessing.Pool`).
        Supply `-1` to use all cores available to the Process.
        Alternatively supply a map-like callable, such as
        `multiprocessing.Pool.map` for evaluating the grid in parallel.
        This evaluation is carried out as ``workers(func, iterable)``.
        Requires that `func` be pickleable.

        .. versionadded:: 1.3.0

    Returns
    -------
    x0 : ndarray
        A 1-D array containing the coordinates of a point at which the
        objective function had its minimum value. (See `Note 1` for
        which point is returned.)
    fval : float
        Function value at the point `x0`. (Returned when `full_output` is
        True.)
    grid : tuple
        Representation of the evaluation grid.  It has the same
        length as `x0`. (Returned when `full_output` is True.)
    Jout : ndarray
        Function values at each point of the evaluation
        grid, `i.e.`, ``Jout = func(*grid)``. (Returned
        when `full_output` is True.)

    See Also
    --------
    basinhopping, differential_evolution

    Notes
    -----
    *Note 1*: The program finds the gridpoint at which the lowest value
    of the objective function occurs.  If `finish` is None, that is the
    point returned.  When the global minimum occurs within (or not very far
    outside) the grid's boundaries, and the grid is fine enough, that
    point will be in the neighborhood of the global minimum.

    However, users often employ some other optimization program to
    "polish" the gridpoint values, `i.e.`, to seek a more precise
    (local) minimum near `brute's` best gridpoint.
    The `brute` function's `finish` option provides a convenient way to do
    that.  Any polishing program used must take `brute's` output as its
    initial guess as a positional argument, and take `brute's` input values
    for `args` as keyword arguments, otherwise an error will be raised.
    It may additionally take `full_output` and/or `disp` as keyword arguments.

    `brute` assumes that the `finish` function returns either an
    `OptimizeResult` object or a tuple in the form:
    ``(xmin, Jmin, ... , statuscode)``, where ``xmin`` is the minimizing
    value of the argument, ``Jmin`` is the minimum value of the objective
    function, "..." may be some other returned values (which are not used
    by `brute`), and ``statuscode`` is the status code of the `finish` program.

    Note that when `finish` is not None, the values returned are those
    of the `finish` program, *not* the gridpoint ones.  Consequently,
    while `brute` confines its search to the input grid points,
    the `finish` program's results usually will not coincide with any
    gridpoint, and may fall outside the grid's boundary. Thus, if a
    minimum only needs to be found over the provided grid points, make
    sure to pass in `finish=None`.

    *Note 2*: The grid of points is a `numpy.mgrid` object.
    For `brute` the `ranges` and `Ns` inputs have the following effect.
    Each component of the `ranges` tuple can be either a slice object or a
    two-tuple giving a range of values, such as (0, 5).  If the component is a
    slice object, `brute` uses it directly.  If the component is a two-tuple
    range, `brute` internally converts it to a slice object that interpolates
    `Ns` points from its low-value to its high-value, inclusive.

    Examples
    --------
    We illustrate the use of `brute` to seek the global minimum of a function
    of two variables that is given as the sum of a positive-definite
    quadratic and two deep "Gaussian-shaped" craters.  Specifically, define
    the objective function `f` as the sum of three other functions,
    ``f = f1 + f2 + f3``.  We suppose each of these has a signature
    ``(z, *params)``, where ``z = (x, y)``,  and ``params`` and the functions
    are as defined below.

    &gt;&gt;&gt; params = (2, 3, 7, 8, 9, 10, 44, -1, 2, 26, 1, -2, 0.5)
    &gt;&gt;&gt; def f1(z, *params):
    ...     x, y = z
    ...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
    ...     return (a * x**2 + b * x * y + c * y**2 + d*x + e*y + f)

    &gt;&gt;&gt; def f2(z, *params):
    ...     x, y = z
    ...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
    ...     return (-g*np.exp(-((x-h)**2 + (y-i)**2) / scale))

    &gt;&gt;&gt; def f3(z, *params):
    ...     x, y = z
    ...     a, b, c, d, e, f, g, h, i, j, k, l, scale = params
    ...     return (-j*np.exp(-((x-k)**2 + (y-l)**2) / scale))

    &gt;&gt;&gt; def f(z, *params):
    ...     return f1(z, *params) + f2(z, *params) + f3(z, *params)

    Thus, the objective function may have local minima near the minimum
    of each of the three functions of which it is composed.  To
    use `fmin` to polish its gridpoint result, we may then continue as
    follows:

    &gt;&gt;&gt; rranges = (slice(-4, 4, 0.25), slice(-4, 4, 0.25))
    &gt;&gt;&gt; from scipy import optimize
    &gt;&gt;&gt; resbrute = optimize.brute(f, rranges, args=params, full_output=True,
    ...                           finish=optimize.fmin)
    &gt;&gt;&gt; resbrute[0]  # global minimum
    array([-1.05665192,  1.80834843])
    &gt;&gt;&gt; resbrute[1]  # function value at global minimum
    -3.4085818767

    Note that if `finish` had been set to None, we would have gotten the
    gridpoint [-1.0 1.75] where the rounded function value is -2.892.

    """
    N = len(ranges)
    if N &gt; 40:
        raise ValueError("Brute Force not possible with more "
                         "than 40 variables.")
    lrange = list(ranges)
    for k in range(N):
        if type(lrange[k]) is not type(slice(None)):
            if len(lrange[k]) &lt; 3:
                lrange[k] = tuple(lrange[k]) + (complex(Ns),)
            lrange[k] = slice(*lrange[k])
    if (N == 1):
        lrange = lrange[0]

    grid = np.mgrid[lrange]

    # obtain an array of parameters that is iterable by a map-like callable
    inpt_shape = grid.shape
    if (N &gt; 1):
        grid = np.reshape(grid, (inpt_shape[0], np.prod(inpt_shape[1:]))).T

    wrapped_func = _Brute_Wrapper(func, args)

    # iterate over input arrays, possibly in parallel
    with MapWrapper(pool=workers) as mapper:
        Jout = np.array(list(mapper(wrapped_func, grid)))
        if (N == 1):
            grid = (grid,)
            Jout = np.squeeze(Jout)
        elif (N &gt; 1):
            Jout = np.reshape(Jout, inpt_shape[1:])
            grid = np.reshape(grid.T, inpt_shape)

    Nshape = shape(Jout)

    indx = argmin(Jout.ravel(), axis=-1)
    Nindx = zeros(N, int)
    xmin = zeros(N, float)
    for k in range(N - 1, -1, -1):
        thisN = Nshape[k]
        Nindx[k] = indx % Nshape[k]
        indx = indx // thisN
    for k in range(N):
        xmin[k] = grid[k][tuple(Nindx)]

    Jmin = Jout[tuple(Nindx)]
    if (N == 1):
        grid = grid[0]
        xmin = xmin[0]

    if callable(finish):
        # set up kwargs for `finish` function
        finish_args = _getargspec(finish).args
        finish_kwargs = dict()
        if 'full_output' in finish_args:
            finish_kwargs['full_output'] = 1
        if 'disp' in finish_args:
            finish_kwargs['disp'] = disp
        elif 'options' in finish_args:
            # pass 'disp' as `options`
            # (e.g. if `finish` is `minimize`)
            finish_kwargs['options'] = {'disp': disp}

        # run minimizer
        res = finish(func, xmin, args=args, **finish_kwargs)

        if isinstance(res, OptimizeResult):
            xmin = res.x
            Jmin = res.fun
            success = res.success
        else:
            xmin = res[0]
            Jmin = res[1]
            success = res[-1] == 0
        if not success:
            if disp:
                print("Warning: Either final optimization did not succeed "
                      "or `finish` does not return `statuscode` as its last "
                      "argument.")

    if full_output:
        return xmin, Jmin, grid, Jout
    else:
        return xmin


class _Brute_Wrapper(object):
    """
    Object to wrap user cost function for optimize.brute, allowing picklability
    """
    def __init__(self, f, args):
        self.f = f
        self.args = [] if args is None else args

    def __call__(self, x):
        # flatten needed for one dimensional case.
        return self.f(np.asarray(x).flatten(), *self.args)


def show_options(solver=None, method=None, disp=True):
    """
    Show documentation for additional options of optimization solvers.

    These are method-specific options that can be supplied through the
    ``options`` dict.

    Parameters
    ----------
    solver : str
        Type of optimization solver. One of 'minimize', 'minimize_scalar',
        'root', or 'linprog'.
    method : str, optional
        If not given, shows all methods of the specified solver. Otherwise,
        show only the options for the specified method. Valid values
        corresponds to methods' names of respective solver (e.g. 'BFGS' for
        'minimize').
    disp : bool, optional
        Whether to print the result rather than returning it.

    Returns
    -------
    text
        Either None (for disp=True) or the text string (disp=False)

    Notes
    -----
    The solver-specific methods are:

    `scipy.optimize.minimize`

    - :ref:`Nelder-Mead &lt;optimize.minimize-neldermead&gt;`
    - :ref:`Powell      &lt;optimize.minimize-powell&gt;`
    - :ref:`CG          &lt;optimize.minimize-cg&gt;`
    - :ref:`BFGS        &lt;optimize.minimize-bfgs&gt;`
    - :ref:`Newton-CG   &lt;optimize.minimize-newtoncg&gt;`
    - :ref:`L-BFGS-B    &lt;optimize.minimize-lbfgsb&gt;`
    - :ref:`TNC         &lt;optimize.minimize-tnc&gt;`
    - :ref:`COBYLA      &lt;optimize.minimize-cobyla&gt;`
    - :ref:`SLSQP       &lt;optimize.minimize-slsqp&gt;`
    - :ref:`dogleg      &lt;optimize.minimize-dogleg&gt;`
    - :ref:`trust-ncg   &lt;optimize.minimize-trustncg&gt;`

    `scipy.optimize.root`

    - :ref:`hybr              &lt;optimize.root-hybr&gt;`
    - :ref:`lm                &lt;optimize.root-lm&gt;`
    - :ref:`broyden1          &lt;optimize.root-broyden1&gt;`
    - :ref:`broyden2          &lt;optimize.root-broyden2&gt;`
    - :ref:`anderson          &lt;optimize.root-anderson&gt;`
    - :ref:`linearmixing      &lt;optimize.root-linearmixing&gt;`
    - :ref:`diagbroyden       &lt;optimize.root-diagbroyden&gt;`
    - :ref:`excitingmixing    &lt;optimize.root-excitingmixing&gt;`
    - :ref:`krylov            &lt;optimize.root-krylov&gt;`
    - :ref:`df-sane           &lt;optimize.root-dfsane&gt;`

    `scipy.optimize.minimize_scalar`

    - :ref:`brent       &lt;optimize.minimize_scalar-brent&gt;`
    - :ref:`golden      &lt;optimize.minimize_scalar-golden&gt;`
    - :ref:`bounded     &lt;optimize.minimize_scalar-bounded&gt;`

    `scipy.optimize.linprog`

    - :ref:`simplex         &lt;optimize.linprog-simplex&gt;`
    - :ref:`interior-point  &lt;optimize.linprog-interior-point&gt;`

    """
    import textwrap

    doc_routines = {
        'minimize': (
            ('bfgs', 'scipy.optimize.optimize._minimize_bfgs'),
            ('cg', 'scipy.optimize.optimize._minimize_cg'),
            ('cobyla', 'scipy.optimize.cobyla._minimize_cobyla'),
            ('dogleg', 'scipy.optimize._trustregion_dogleg._minimize_dogleg'),
            ('l-bfgs-b', 'scipy.optimize.lbfgsb._minimize_lbfgsb'),
            ('nelder-mead', 'scipy.optimize.optimize._minimize_neldermead'),
            ('newton-cg', 'scipy.optimize.optimize._minimize_newtoncg'),
            ('powell', 'scipy.optimize.optimize._minimize_powell'),
            ('slsqp', 'scipy.optimize.slsqp._minimize_slsqp'),
            ('tnc', 'scipy.optimize.tnc._minimize_tnc'),
            ('trust-ncg', 'scipy.optimize._trustregion_ncg._minimize_trust_ncg'),
        ),
        'root': (
            ('hybr', 'scipy.optimize.minpack._root_hybr'),
            ('lm', 'scipy.optimize._root._root_leastsq'),
            ('broyden1', 'scipy.optimize._root._root_broyden1_doc'),
            ('broyden2', 'scipy.optimize._root._root_broyden2_doc'),
            ('anderson', 'scipy.optimize._root._root_anderson_doc'),
            ('diagbroyden', 'scipy.optimize._root._root_diagbroyden_doc'),
            ('excitingmixing', 'scipy.optimize._root._root_excitingmixing_doc'),
            ('linearmixing', 'scipy.optimize._root._root_linearmixing_doc'),
            ('krylov', 'scipy.optimize._root._root_krylov_doc'),
            ('df-sane', 'scipy.optimize._spectral._root_df_sane'),
        ),
        'root_scalar': (
            ('bisect', 'scipy.optimize._root_scalar._root_scalar_bisect_doc'),
            ('brentq', 'scipy.optimize._root_scalar._root_scalar_brentq_doc'),
            ('brenth', 'scipy.optimize._root_scalar._root_scalar_brenth_doc'),
            ('ridder', 'scipy.optimize._root_scalar._root_scalar_ridder_doc'),
            ('toms748', 'scipy.optimize._root_scalar._root_scalar_toms748_doc'),
            ('secant', 'scipy.optimize._root_scalar._root_scalar_secant_doc'),
            ('newton', 'scipy.optimize._root_scalar._root_scalar_newton_doc'),
            ('halley', 'scipy.optimize._root_scalar._root_scalar_halley_doc'),
        ),
        'linprog': (
            ('simplex', 'scipy.optimize._linprog._linprog_simplex'),
            ('interior-point', 'scipy.optimize._linprog._linprog_ip'),
        ),
        'minimize_scalar': (
            ('brent', 'scipy.optimize.optimize._minimize_scalar_brent'),
            ('bounded', 'scipy.optimize.optimize._minimize_scalar_bounded'),
            ('golden', 'scipy.optimize.optimize._minimize_scalar_golden'),
        ),
    }

    if solver is None:
        text = ["\n\n\n========\n", "minimize\n", "========\n"]
        text.append(show_options('minimize', disp=False))
        text.extend(["\n\n===============\n", "minimize_scalar\n",
                     "===============\n"])
        text.append(show_options('minimize_scalar', disp=False))
        text.extend(["\n\n\n====\n", "root\n",
                     "====\n"])
        text.append(show_options('root', disp=False))
        text.extend(['\n\n\n=======\n', 'linprog\n',
                     '=======\n'])
        text.append(show_options('linprog', disp=False))
        text = "".join(text)
    else:
        solver = solver.lower()
        if solver not in doc_routines:
            raise ValueError('Unknown solver %r' % (solver,))

        if method is None:
            text = []
            for name, _ in doc_routines[solver]:
                text.extend(["\n\n" + name, "\n" + "="*len(name) + "\n\n"])
                text.append(show_options(solver, name, disp=False))
            text = "".join(text)
        else:
            method = method.lower()
            methods = dict(doc_routines[solver])
            if method not in methods:
                raise ValueError("Unknown method %r" % (method,))
            name = methods[method]

            # Import function object
            parts = name.split('.')
            mod_name = ".".join(parts[:-1])
            __import__(mod_name)
            obj = getattr(sys.modules[mod_name], parts[-1])

            # Get doc
            doc = obj.__doc__
            if doc is not None:
                text = textwrap.dedent(doc).strip()
            else:
                text = ""

    if disp:
        print(text)
        return
    else:
        return text


def main():
    import time

    times = []
    algor = []
    x0 = [0.8, 1.2, 0.7]
    print("Nelder-Mead Simplex")
    print("===================")
    start = time.time()
    x = fmin(rosen, x0)
    print(x)
    times.append(time.time() - start)
    algor.append('Nelder-Mead Simplex\t')

    print()
    print("Powell Direction Set Method")
    print("===========================")
    start = time.time()
    x = fmin_powell(rosen, x0)
    print(x)
    times.append(time.time() - start)
    algor.append('Powell Direction Set Method.')

    print()
    print("Nonlinear CG")
    print("============")
    start = time.time()
    x = fmin_cg(rosen, x0, fprime=rosen_der, maxiter=200)
    print(x)
    times.append(time.time() - start)
    algor.append('Nonlinear CG     \t')

    print()
    print("BFGS Quasi-Newton")
    print("=================")
    start = time.time()
    x = fmin_bfgs(rosen, x0, fprime=rosen_der, maxiter=80)
    print(x)
    times.append(time.time() - start)
    algor.append('BFGS Quasi-Newton\t')

    print()
    print("BFGS approximate gradient")
    print("=========================")
    start = time.time()
    x = fmin_bfgs(rosen, x0, gtol=1e-4, maxiter=100)
    print(x)
    times.append(time.time() - start)
    algor.append('BFGS without gradient\t')

    print()
    print("Newton-CG with Hessian product")
    print("==============================")
    start = time.time()
    x = fmin_ncg(rosen, x0, rosen_der, fhess_p=rosen_hess_prod, maxiter=80)
    print(x)
    times.append(time.time() - start)
    algor.append('Newton-CG with hessian product')

    print()
    print("Newton-CG with full Hessian")
    print("===========================")
    start = time.time()
    x = fmin_ncg(rosen, x0, rosen_der, fhess=rosen_hess, maxiter=80)
    print(x)
    times.append(time.time() - start)
    algor.append('Newton-CG with full hessian')

    print()
    print("\nMinimizing the Rosenbrock function of order 3\n")
    print(" Algorithm \t\t\t       Seconds")
    print("===========\t\t\t      =========")
    for k in range(len(algor)):
        print(algor[k], "\t -- ", times[k])


if __name__ == "__main__":
    main()</pre>
<h3>Optimization</h3>
<p><a href="https://github.com/optimization-js/optimization-js">https://github.com/optimization-js/optimization-js</a> </p>
<p><a href="https://stackoverflow.com/questions/957537/how-can-i-display-a-javascript-object">https://stackoverflow.com/questions/957537/how-can-i-display-a-javascript-object</a> </p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;script src="/static/optimization.js"&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;p id="result"&gt;&lt;/p&gt;
&lt;p&gt;
&lt;script&gt;
// objective that needs to be minimized
fnc = function (v) {
  var result = 0.0;
  for (var i = 0; i &lt; v.length; i++){
    result = result + v[i] * v[i]
  }
  return result;
};

var x0 = [1.0, -1.0, 0.5, -0.5, 0.25, -0.25]; // a somewhat random initial vector

// Powell method can be applied to zero order unconstrained optimization
var solution = optimjs.minimize_Powell(fnc, x0);
output = JSON.stringify(solution, null, 4);
document.getElementById("result").innerHTML = output;
&lt;/script&gt;</pre>
<p>
<script src="/static/optimization.js"></script>
</p>
<p id="result"></p>
<p>
<script>
// objective that needs to be minimized
fnc = function (v) {
  var result = 0.0;
  for (var i = 0; i < v.length; i++){
    result = result + v[i] * v[i]
  }
  return result;
};

var x0 = [1.0, -1.0, 0.5, -0.5, 0.25, -0.25]; // a somewhat random initial vector

// Powell method can be applied to zero order unconstrained optimization
var solution = optimjs.minimize_Powell(fnc, x0);
output = JSON.stringify(solution, null, 4);
document.getElementById("result").innerHTML = output;
</script>
</p>
<h1>網際內容管理</h1>
<p>網際內容管理系統流程:</p>
<ol>
<li>管理者安全地利用瀏覽器登入系統</li>
<li>編輯頁面, 引用檔案或網站連結</li>
<li>存檔</li>
<li>上傳檔案</li>
<li>將動態網頁系統轉為靜態網頁內容</li>
</ol>
<h4>Django</h4>
<p><a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a> </p>
<p><a href="https://github.com/HuyLafa/MathTutor">https://github.com/HuyLafa/MathTutor</a> </p>
<h4>Flask</h4>
<p><a href="http://flask.pocoo.org/">http://flask.pocoo.org/</a> </p>
<p><a href="https://kirankoduru.github.io/python/flask-cms-app.html">https://kirankoduru.github.io/python/flask-cms-app.html</a> </p>
<p><a href="https://github.com/kirankoduru/flask-cms-demo">https://github.com/kirankoduru/flask-cms-demo</a> </p>
<h4>Tornado</h4>
<p><a href="https://www.tornadoweb.org/en/stable/">https://www.tornadoweb.org/en/stable/</a> </p>
<h4>Gunicorn</h4>
<p><a href="https://gunicorn.org/">https://gunicorn.org/</a> </p><h1>參考資料</h1>
<h4>Python 教材</h4>
<p><a href="https://www.python-course.eu">https://www.python-course.eu</a> </p>
<p><a href="http://mde.tw/cp2018">http://mde.tw/cp2018</a> </p>
<p><a href="https://mdecp2018.github.io/finalproject-bgx">https://mdecp2018.github.io/finalproject-bgx</a> </p>
<h4>物件導向</h4>
<p><a href="https://jeffknupp.com/blog/2014/06/18/improve-your-python-python-classes-and-object-oriented-programming/">https://jeffknupp.com/blog/2014/06/18/improve-your-python-python-classes-and-object-oriented-programming/</a> </p>
<p><a href="https://python-textbok.readthedocs.io/en/1.0/Object_Oriented_Programming.html">https://python-textbok.readthedocs.io/en/1.0/Object_Oriented_Programming.html</a> </p>
<h4>Python 網際框架</h4>
<p><a href="http://flask.pocoo.org/">http://flask.pocoo.org/</a></p>
<p><a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a> </p>
<h4>Parsing</h4>
<p><a href="http://loup-vaillant.fr/tutorials/earley-parsing/">http://loup-vaillant.fr/tutorials/earley-parsing/</a> </p>
<p><a href="https://tomassetti.me/parsing-in-python/">https://tomassetti.me/parsing-in-python/</a> (<a href="/downloads/Parsing%20in Python_ all the tools and libraries you can use.pdf">pdf</a>)</p>
<p><a href="https://github.com/lark-parser/lark">https://github.com/lark-parser/lark</a> (<a href="/downloads/erezsh_lark.pdf">erezsh_lark.pdf</a>)</p>
<h4>Algorithm</h4>
<p><a href="https://medium.com/100-days-of-algorithms">https://medium.com/100-days-of-algorithms</a>  (<a href="https://medium.com/@tomas.bouda">https://medium.com/@tomas.bouda</a> )</p>
<h4>其他程式語言</h4>
<p><a href="https://en.wikipedia.org/wiki/JavaScript">https://en.wikipedia.org/wiki/JavaScript</a> </p>
<h1>電子書</h1>
<h4>Learn to Program with Python 3 - A Step-by-Step Guide to Programming</h4>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-3879-0">https://link.springer.com/book/10.1007/978-1-4842-3879-0</a> </p>
<h4>Beginning Python - From Novice to Professional</h4>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-0028-5">https://link.springer.com/book/10.1007/978-1-4842-0028-5</a> </p>
<h4>Programming with Python</h4>
<p><a href="https://link.springer.com/book/10.1007/978-981-10-3277-6">https://link.springer.com/book/10.1007/978-981-10-3277-6</a> </p>
<h4>Python Recipes Handbook - A Problem-Solution Approach</h4>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-0241-8">https://link.springer.com/book/10.1007/978-1-4842-0241-8</a> </p>
<h4>Beginning Django Web Application Development and Deployment with Python</h4>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-2787-9">https://link.springer.com/book/10.1007/978-1-4842-2787-9</a> </p>
<h4>Python 2 and 3 Compatibility - With Six and Python-Future Libraries</h4>
<p><a href="https://link.springer.com/book/10.1007/978-1-4842-2955-2">https://link.springer.com/book/10.1007/978-1-4842-2955-2</a> </p>
<h4>Elementary Mechanics Using Python - A Modern Course Combining Analytical and Numerical Techniques</h4>
<p><a href="https://link.springer.com/book/10.1007/978-3-319-19596-4">https://link.springer.com/book/10.1007/978-3-319-19596-4</a> (Python2)</p>
<h4>Programming for Computations - Python A Gentle Introduction to Numerical Simulations with Python</h4>
<p><a href="https://link.springer.com/book/10.1007/978-3-319-32428-9">https://link.springer.com/book/10.1007/978-3-319-32428-9</a> (Python2)</p>
<h4>LaTeX in 24 Hours - A Practical Guide for Scientific Writing</h4>
<p><a href="https://link.springer.com/book/10.1007/978-3-319-47831-9">https://link.springer.com/book/10.1007/978-3-319-47831-9</a> </p>
<h4>Practical LaTeX</h4>
<p><a href="https://link.springer.com/book/10.1007/978-3-319-06425-3">https://link.springer.com/book/10.1007/978-3-319-06425-3</a> (<a href="https://ctan.org/pkg/practical-latex?lang=en">sample files</a>)</p>
<h4>LaTeX and Friends</h4>
<p><a href="https://link.springer.com/book/10.1007/978-3-642-23816-1">https://link.springer.com/book/10.1007/978-3-642-23816-1</a> </p>
<h4>Math into LATEX</h4>
<p><a href="https://link.springer.com/book/10.1007/978-1-4612-2134-0">https://link.springer.com/book/10.1007/978-1-4612-2134-0</a> </p>